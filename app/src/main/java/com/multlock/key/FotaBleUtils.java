

package com.multlock.key;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;

import org.apache.http.util.ByteArrayBuffer;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.ParcelUuid;
import android.util.Log;
import android.util.SparseArray;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class FotaBleUtils {

	
	private static final String TAG = "MTLT_FOTA_BLE";
	private static final byte LOCAL_PAYLOAD = 0;
	private static final byte PRIMARY_PAYLOAD = 1;

	private static ByteArrayBuffer primaryPayloadAccumulation = new ByteArrayBuffer(256);
	private static int fotaCommand = 0;
	private int fotaExpectedChksum = 0;
	private static int fotaExpectedLength = 0;
	private int fotaAccumulatedLength = 0;
	private static byte fotaCounter = 0;

	// length of values for control and payload
	private final int CMD_LEN = 1;
	private final int PAYLOAD_LOCATION_LEN = 1;
	private final int DATA_LENGHT_LEN = 2;
	private final int CHKSUM_LEN = 1;
	private final int COUNTER_LEN = 1;
	private final int PAYLOAD_LENGTH_LEN = 1;

	// location in byte[] of information in Control
	private final int CTRL_CMD_LOCATION = 0;
	private final int CTRL_PAYLOAD_TYPE_LOCATION = CMD_LEN;
	private final int CTRL_PAYLOAD_LENGTH_LOCATION = CTRL_PAYLOAD_TYPE_LOCATION + PAYLOAD_LOCATION_LEN;
	private final int CTRL_PAYLOAD_CHKSUM_LOCATION = CTRL_PAYLOAD_LENGTH_LOCATION + DATA_LENGHT_LEN;
	private final int CTRL_HEADER_CHKSUM_LOCATION = CTRL_PAYLOAD_CHKSUM_LOCATION + CHKSUM_LEN;
	private final int CTRL_PAYLOAD_LOCATION = CTRL_HEADER_CHKSUM_LOCATION + CHKSUM_LEN;

	// location in byte[] of information in Payload
	private final int PAYLOAD_COUNTER_LOCATION = 0;
	private final int PAYLOAD_LENGTH_LOCATION = PAYLOAD_COUNTER_LOCATION + COUNTER_LEN;
	private final int PAYLOAD_DATA_LOCATION = PAYLOAD_LENGTH_LOCATION + COUNTER_LEN;

	/* UUIDs generated by def */
	
	public static final UUID FOTA_SERVICE = UUID.fromString("c5e00500-d396-11e3-bb18-0002a5d5c51b");
	public static final UUID FOTA_REQUEST_CONTROL = UUID.fromString("c5e00501-d396-11e3-bb18-0002a5d5c51b");
	public static final UUID FOTA_REQUEST_PAYLOAD = UUID.fromString("c5e00502-d396-11e3-bb18-0002a5d5c51b");
	public static final UUID FOTA_RESPONSE_CONTROL = UUID.fromString("c5e00503-d396-11e3-bb18-0002a5d5c51b");
	public static final UUID FOTA_RESPONSE_PAYLOAD = UUID.fromString("c5e00504-d396-11e3-bb18-0002a5d5c51b");


	private static final int MAX_PAYLOAD_BUFFER = 18;
	private static final int MAX_LOCAL_PAYLOAD_BUFFER = 14;
	
	public static BluetoothGattService fotaService = null;

	private ByteArrayBuffer controlBuffer;
	private ByteArrayBuffer payloadBuffer;
	
	private final boolean securityOn = true;

	private boolean useFOTASecurity = true;
	
	private BleInterface ble_interface;
	
	private static int[] ackArray = null;	
	
	private static int startChunk = 0;

	private boolean sentComplete = false;
	private final int checkAckArrayInterval = 1500;
	private Handler mHandler = null;
    private boolean breakDownload = false;
	
	public FotaBleUtils(BleInterface ble_int, Handler handler)
	{
		ble_interface = ble_int;
		controlBuffer = new ByteArrayBuffer(20);
		payloadBuffer = new ByteArrayBuffer(20);
		this.mHandler = handler;
	}

	
	private int fromByteArray(byte[] bytes) {
		int res = 0;
		for (int i = 0; i < bytes.length; i++)
			res = res * 2 + bytes[i];
		
	     return res;
	}

	public static Object fotaObject = new Object();

	public void setControlProfile(int index, byte cmd, byte pl_location, short len, byte payload_chksum, byte[] data) {
		if (index < 0)
			return;
		//BleUtils.mActiveGatt = this.getGattFromId(index);
		BleUtils.mActiveIndex = index;
		if (BleUtils.mActiveGatt == null)
			return;
		byte[] tmp1 = new byte[1];
		tmp1[0] = cmd;

		controlBuffer.clear();
		
		controlBuffer.append(tmp1, 0, CMD_LEN);// command
		
		byte[] tmp2 = new byte[2];
		tmp1[0] = pl_location;
		controlBuffer.append(tmp1, 0, PAYLOAD_LOCATION_LEN);// payload location
															// - local, primary,
															// secondary
		tmp2[0] = (byte) (len & 0xff);
		tmp2[1] = (byte) ((len >> 8) & 0xff);
		controlBuffer.append(tmp2, 0, DATA_LENGHT_LEN);// payload size
		tmp1[0] = payload_chksum;// checksum of total payload
		controlBuffer.append(tmp1, 0, CHKSUM_LEN);// payload checksum
		tmp1[0] = (byte) calculateChecksum(0, CTRL_HEADER_CHKSUM_LOCATION, controlBuffer.buffer());// checksum
																									// of
																									// current
																									// data
		controlBuffer.append(tmp1, 0, CHKSUM_LEN);// control checksum
		if (data != null)
			controlBuffer.append(data, 0, data.length);// data

	}

	public boolean sendPayload(byte[] data) {
		if (BleUtils.mActiveGatt == null)
			return false;
		boolean b;
		byte count = 1;
		int total_length = data.length;
		int left_length = total_length;
		BluetoothGattCharacteristic characteristic = fotaService.getCharacteristic(FOTA_REQUEST_PAYLOAD);
		characteristic.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
										// 2=DEFAULT;4=WRITE_TYPE_SIGNED

		int accumulatedOffset = 0;
		byte[] tmp1 = new byte[1];

		while (left_length > 0) {
			payloadBuffer.clear();
			tmp1[0] = (left_length > MAX_PAYLOAD_BUFFER ? count++ : (byte) (0xFE | count));
			payloadBuffer.append(tmp1, 0, COUNTER_LEN);
			int len = (left_length < MAX_PAYLOAD_BUFFER ? (byte) left_length : (byte) MAX_PAYLOAD_BUFFER);
			tmp1[0] = (byte) len;// calculateChecksum(accumulatedOffset, len,
									// data);
			payloadBuffer.append(tmp1, 0, PAYLOAD_LENGTH_LEN);
			payloadBuffer.append(data, accumulatedOffset, len);
			accumulatedOffset += len;
			try {
				// wait for previous write to end
				synchronized (fotaObject) {
					// long time1 = System.currentTimeMillis();
					fotaObject.wait(200);
					//long time2 = System.currentTimeMillis();
					// long delta = time2 - time1;
					//Log.i(TAG, "payload sending time: " + time2);

				}
				Thread.sleep(5);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalMonitorStateException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			b = characteristic.setValue(payloadBuffer.buffer());
			if (!b)
				return false;
			// time_before = System.currentTimeMillis();
			if (BleUtils.mActiveGatt == null)
				return false;
			b = BleUtils.mActiveGatt.writeCharacteristic(characteristic);
			if (!b)
				return false;

			// for test
			// this.handlePayloadResponse(payloadBuffer.buffer(), true);

			left_length -= MAX_PAYLOAD_BUFFER;
		}
		return true;
	}
	
	private boolean sendCommand(byte command, ByteArrayBuffer data, int connectionIndex)
	{
		// no length and IV - use data
		
		int index = connectionIndex;
		
		byte chksum = calculateChecksum(0, data.length(), data.toByteArray());

		if (data.length() <= FotaBleUtils.MAX_LOCAL_PAYLOAD_BUFFER)
			setControlProfile(index, command, LOCAL_PAYLOAD, (short) data.length(), (byte) chksum, data.buffer());
		else
			setControlProfile(index, command, PRIMARY_PAYLOAD, (short) data.length(), (byte) chksum, null);

		boolean b = sendControl(controlBuffer.buffer());
		if (!b)
			return false;

		if (data.length() > FotaBleUtils.MAX_LOCAL_PAYLOAD_BUFFER)
			return sendPayload(data.buffer());
		else
			return true;
	}

	public boolean handleControlResponse(byte[] data) {
		Bundle bundle = null;

		int control_chksum = getControlChksumFromResponse(data);
		if (!verifyChecksum(5, data, control_chksum)) {
			Log.e(TAG, "Checksum error");
			return false;
		}
		int cmd = getCommandFromResponse(data);
		
		int payload_location = getPayloadLocationFromResponse(data);
		int expectedLength = getPayloadLengthFromResponse(data);
		int expectedChksum = getPayloadChksumFromResponse(data);

		if (payload_location == LOCAL_PAYLOAD) {
			// get payload from control
			byte[] payload = null;
			if (expectedLength > 0)
				payload = getPayloadFromResponse(data, expectedLength);
			
			boolean bRC = handlePayloadContent(payload, cmd);
			
			if (!bRC)
				return false;

		} else {
			if (payload_location == PRIMARY_PAYLOAD) {
				// payload in primary response
				fotaCommand = cmd;
				fotaExpectedChksum = expectedChksum;
				fotaExpectedLength = expectedLength;
				fotaAccumulatedLength = 0;
				fotaCounter = 0;
				this.primaryPayloadAccumulation.clear();
			} 
		}
		return true;
	}

	public boolean handlePayloadResponse(byte[] data, boolean isPrimaryData) {
		Bundle bundle = null;
		int cmd = 0;

		BluetoothGattCharacteristic characteristic;
		ByteArrayBuffer buffer = null;
		int count = getCounterFrompayload(data);

		// int chksum = getChksumFromPayloadResponse(data);
		// if (!verifyChecksum(data.length, data, chksum))
		// return false;
		boolean isLast = false;
		if (isPrimaryData) {
			isLast = isLastBuffer(data, ++fotaCounter);
			if (fotaCounter != count && !isLast) {
				return false;
			}
			characteristic = fotaService.getCharacteristic(this.FOTA_RESPONSE_PAYLOAD);
			buffer = this.primaryPayloadAccumulation;
			cmd = fotaCommand;
//			if (count == 1)
//				buffer.clear();
		} 
		int length = getPayloadLengthFromPayloadResponse(data);

		buffer.append(data, PAYLOAD_DATA_LOCATION, length);
		this.fotaAccumulatedLength += length;
		if (isLast) {
			boolean b = this.verifyChecksum(fotaAccumulatedLength, buffer.buffer(), this.fotaExpectedChksum);
			if (!b) {
				Log.e(TAG, "checksum error");
				return false;
			}
			
			ByteArrayBuffer payload = new ByteArrayBuffer(fotaAccumulatedLength);
			payload.append(buffer.buffer(), 0, fotaAccumulatedLength);
			
			//future use - merge code to handle cases
			b = handlePayloadContent(payload.buffer(), cmd);
		}
		return true;
	}
	
	private boolean handlePayloadContent(byte[] payload, int cmd)
	{
		Bundle bundle = null;
		int expCommand = 0;
		
		
		switch (cmd) {
		
//		case Utils.ENUM_CMD_SEND_PUBLIC_KEY:
//			bundle = getPublicKeyBundle(payload);
//			ble_interface.onSendPublicKeyResponse(bundle);
//			expCommand = cmd;
//			break;
		case Utils.ENUM_CMD_OP_SUCCESS_IMP:
			ble_interface.onLastRequestSuccess();
			break;
		case Utils.ENUM_CMD_OP_SUCCESS_EXP:
			bundle = getOnSuccessBundle(payload);
			ble_interface.onRequestSuccess(bundle);
			expCommand = bundle.getByte(Utils.STR_COMMAND);
			break;
		case Utils.ENUM_CMD_OP_ERROR:
			bundle = getOnErrorBundle(payload);
			ble_interface.onRequestError(bundle);
			expCommand = bundle.getByte(Utils.STR_COMMAND);
			break;
		case Utils.ENUM_CMD_OP_STATUS:
			bundle = getOnOpStatusBundle(payload);
			if (bundle != null)
				ble_interface.onStatusResponse(bundle);
			break;
		case Utils.ENUM_CMD_GET_COMMUNICATION_VERSION_RESPONSE:
			bundle = getOnGetCommVersionResponseBundle(payload);
			if (bundle != null)
				ble_interface.onGetCommVersionResponse(bundle);
			expCommand = Utils.ENUM_CMD_GET_COMMUNICATION_VERSION;
			break;
        case Utils.ENUM_CMD_GET_IV_RESPONSE:
            bundle = getOnGetIvResponseBundle(payload);
            if (bundle != null)
                ble_interface.onGetIvResponse(bundle);
            expCommand = Utils.ENUM_CMD_GET_IV;
            break;
		case Utils.ENUM_CMD_GENERAL_ENCRYPTED:
			// decrypt buffer
			payload = getDecryptedData(payload);
			if (payload == null)
				return false;
			//this.handlePayloadResponse(clearData, true); - commented out last fix
		case Utils.ENUM_CMD_GENERAL_PLAIN:
			int internalCmd = payload[Utils.EXPLICIT_SUCCESS_COMMAND_LOCATION];
			switch (internalCmd) {
				case Utils.ENUM_CMD_OP_SUCCESS_EXP:
					bundle = getOnExplicitSuccessBundle(payload);
					ble_interface.onRequestSuccess(bundle);
					expCommand = bundle.getByte(Utils.STR_COMMAND);
					break;
					
//				case Utils.ENUM_CMD_HANDSHAKE1:
//					bundle = getHandshakeBundle(payload);
//					ble_interface.onHandshakeResponse(bundle);
//					ble_interface.onBleReady2Comm(bundle);
//					expCommand = Utils.ENUM_CMD_HANDSHAKE1;
//					break;
//				case Utils.ENUM_CMD_KDF_RESPONSE:
//					bundle = getKdfResponseBundle(payload);
//					ble_interface.onKdfResponse(bundle);
//					ble_interface.onBleReady2Comm(bundle);
//					expCommand = Utils.ENUM_CMD_KDF;
//					break;

				case Utils.ENUM_CMD_GET_DEVICE_INFO_RESPONSE:
					bundle = getOnGetDeviceInfoResponseBundle(payload);
					if (bundle != null)
						ble_interface.onGetDeviceInfoResponse(bundle);
					expCommand = Utils.ENUM_CMD_GET_DEVICE_INFO;
					break;
				case Utils.ENUM_CMD_DOWNLOAD_PARAMS_RESPONSE:
					bundle = getOnDownloadParamsResponseBundle(payload);
					if (bundle != null)
						ble_interface.onDownloadParamsResponse(bundle);
					expCommand = Utils.ENUM_CMD_DOWNLOAD_PARAMS_REQUEST;
					break;
				case Utils.ENUM_CMD_DOWNLOAD_COMPLETE_RESPONSE:
					bundle = getOnDownloadCompleteResponseBundle(payload);
					if (bundle != null)
						ble_interface.onDownloadCompleteResponse(bundle);
					expCommand = Utils.ENUM_CMD_DOWNLOAD_COMPLETE;
					break;
				case Utils.ENUM_CMD_INSTALL_STATUS:
					bundle = getOnInstallStatusBundle(payload);
					if (bundle != null)
						ble_interface.onInstallStatus(bundle);
					expCommand = Utils.ENUM_CMD_INSTALL_REQUEST;
					break;
				case Utils.ENUM_CMD_DOWNLOAD_CHUNK_STATUS:
					bundle = getOnDownloadChunkStatusBundle(payload);
					if (bundle != null)
						ble_interface.onDownloadChunkStatus(bundle);
					expCommand = Utils.ENUM_CMD_INSTALL_REQUEST;
					break;
				case Utils.ENUM_CMD_GET_ERRORS_RESPONSE:
					bundle = getOnGetErrorsResponseBundle(payload);
					if (bundle != null)
						ble_interface.onGetErrorsResponse(bundle);
					expCommand = Utils.ENUM_CMD_GET_ERRORS;
					break;
					
				default:
					break;
			}
			break;
		default:
			break;
		}
		
//		stopTimer(expCommand);
		
		return true;
	}
	
	private byte[] getDecryptedData(byte[] payload) {
//		byte[] iv = Arrays.copyOfRange(payload, 0, SecUtils.getIvLength());
//		byte[] len = Arrays.copyOfRange(payload, SecUtils.getIvLength(), SecUtils.getIvLength() + this.DATA_LENGHT_LEN);
//		int iLen = len[1] * 256 + len[0];
//		byte[] encData = Arrays.copyOfRange(payload, SecUtils.getIvLength() + this.DATA_LENGHT_LEN, SecUtils.getIvLength() + this.DATA_LENGHT_LEN + iLen);

		byte[] clearData = null;
		try {
//			clearData = SecUtils.decrypt(null, encData, iv);
			//payload is pure encryption
			clearData = SecUtils.decrypt2(null, payload, null);
		} catch (GeneralSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return clearData;
	}

	private boolean verifyChecksum(int length, byte[] data, int Checksum_To_Compare) {
		if (calculateChecksum(0, length, data) == Checksum_To_Compare)
			return true; // Checksum is correct, data is valid

		return false; // Error in checksum, data is invalid
	}

	private byte calculateChecksum(int offset, int length, byte[] data) {
		if (offset > data.length)
			return -1;
		if (length + offset > data.length)
			length = data.length - offset;
		int sum = 0;
		byte Calc_Checksum;

		for (int i = offset; i < offset + length; i++)
			sum += (data[i] >= 0 ? data[i] : data[i] + 256);

		String s = new String(data);

		Calc_Checksum = (byte) (sum >> 8);
		Calc_Checksum += sum;
		Calc_Checksum += 0xA0;

		return Calc_Checksum;
	}

	private int getCommandFromResponse(byte[] data) {
		return data[CTRL_CMD_LOCATION];
	}

	private int getPayloadLocationFromResponse(byte[] data) {
		return data[CTRL_PAYLOAD_TYPE_LOCATION];
	}

	private int getPayloadLengthFromResponse(byte[] data) {
		return ((int) data[CTRL_PAYLOAD_LENGTH_LOCATION + 1] << 8) | ((int) data[CTRL_PAYLOAD_LENGTH_LOCATION] & 0xFF);
	}

	private int getPayloadChksumFromResponse(byte[] data) {
		return data[CTRL_PAYLOAD_CHKSUM_LOCATION];
	}

	private int getControlChksumFromResponse(byte[] data) {
		return data[CTRL_HEADER_CHKSUM_LOCATION];
	}

	private byte[] getPayloadFromResponse(byte[] data, int size) {
		if (data == null)
			return null;
		return Arrays.copyOfRange(data, CTRL_PAYLOAD_LOCATION, CTRL_PAYLOAD_LOCATION + size);
	}

	private int getPayloadLengthFromPayloadResponse(byte[] data) {
		return data[PAYLOAD_LENGTH_LOCATION];
	}

	private boolean isLastBuffer(byte[] data, byte expected) {
		byte counter = data[0];
		byte expectedValue = (byte) ((byte) (0xFE) | expected);
		return (expectedValue == counter);
	}

	private int getCounterFrompayload(byte[] data) {
		byte counter = data[0];
		return (int) counter;
	}

	private boolean sendControl(byte[] message) {
		Boolean b;
		
		if (BleUtils.mActiveGatt == null)
			return false;
		
//		cmdService = BleUtils.mActiveGatt.getService(REQUEST_SERVICE);
//		if (cmdService == null)
//			return false;

		if (fotaService == null)
			return false;
		BluetoothGattCharacteristic characteristic = fotaService.getCharacteristic(FOTA_REQUEST_CONTROL);
		characteristic.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
										// 2=DEFAULT;4=WRITE_TYPE_SIGNED

		b = characteristic.setValue(message);
		if (!b)
			return false;

		b = BleUtils.mActiveGatt.writeCharacteristic(characteristic);
		long time2 = System.currentTimeMillis();
		Log.i(TAG, "payload sending time: " + time2);
		if (!b)
			return false;

		return true;
	}
	
	
	private ByteArrayBuffer getBuffer2FromBundle(Bundle params, byte cmd, int[] itemsLengths, String[] items, boolean encrypted)
	{	
		int fullSize = 0;
		byte[] currentBytes = null;
		byte[] currentByte = new byte[1];
		byte[] command = new byte[CMD_LEN];
		
		for (int i=0; i<itemsLengths.length; i++)
			fullSize += itemsLengths[i];
		
		ByteArrayBuffer data = new ByteArrayBuffer(fullSize);
		
		for (int i=0; i<itemsLengths.length; i++)
		{
			String current = items[i];
			if (current.equals(Utils.STR_COMMAND)) {
				command[0] = cmd;
				currentBytes = command;
			} else {
				if (itemsLengths[i] > 1) {
					currentBytes = params.getByteArray(current);
				}
				else {
					currentByte[0] = params.getByte(current, (byte)0);
					currentBytes = currentByte;
				}
			} 			
			
			data.append(currentBytes, 0, itemsLengths[i]);
		}
		if (this.securityOn && encrypted)
			try {
				byte[] tmpBuffer = SecUtils.encrypt2(null, data.buffer(), null);
				if (tmpBuffer == null)
					return null;
				
				//no IV - append only encrypted data
				data = new ByteArrayBuffer(tmpBuffer.length);
				data.append(tmpBuffer, 0, tmpBuffer.length);
			} catch (GeneralSecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
		return data;
	}
	
//	public boolean handShake(Bundle params) {
//		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
//		byte command = Utils.ENUM_CMD_HANDSHAKE1;
//		
//		int[] itemsLengths = {CMD_LEN, Utils.APP_ID_LENGTH};
//		String[] items = {Utils.STR_COMMAND, Utils.STR_APP_ID};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, true);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
//		
//		return b;
//	}
	
	public boolean downloadParamsRequest(Bundle params) 
	{
		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;;
		byte command = Utils.ENUM_CMD_DOWNLOAD_PARAMS_REQUEST;
		
		int[] itemsLengths = {CMD_LEN, Utils.DP_LENGTH_LENGTH, Utils.DP_FLAGS_LENGTH, Utils.PREFERRED_START_ADDRESS_LENGTH, Utils.PREFERRED_CHUNK_SIZE_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_DP_LENGTH, Utils.STR_DP_FLAGS, Utils.STR_PREFERRED_START_ADDRESS, Utils.STR_PREFERRED_CHUNK_SIZE};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, false);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
//		if (b)
//			startTimer(command);
		
		return b;
	}


    public boolean downloadParamsChangeRequest(Bundle params)
    {
        byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;;
        byte command = Utils.ENUM_CMD_DOWNLOAD_PARAMS_CHANGE_REQUEST;

        int[] itemsLengths = {CMD_LEN, Utils.PREFERRED_START_ADDRESS_LENGTH, Utils.PREFERRED_CHUNK_SIZE_LENGTH};
        String[] items = {Utils.STR_COMMAND, Utils.STR_PREFERRED_START_ADDRESS, Utils.STR_PREFERRED_CHUNK_SIZE};

        ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, false);

        if (data == null)
            return false;

        boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);

//		if (b)
//			startTimer(command);

        return b;
    }

    public static int OTABytesSent(int chunkSize)
    {
        int iRC = 0;
        if (ackArray == null)
            return 0;
        for (int i=0; i<ackArray.length; i++) {
            if (ackArray[i] == 0)
                iRC += chunkSize;
            else
                break;
        }
        return iRC;
    }
	
	private byte[] otaData = null;

	int preferredChunkSize = 256;
	
	public boolean otaUpdate(Bundle params) {
		
		Bundle bundle = new Bundle();
		
		boolean success = true;
		
		otaData = params.getByteArray(Utils.STR_OTA_UPDATE_DATA);
		
		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE, 512);
		
		int bytesSent = 0;
		int startAddress = 0;
		
		if (ackArray != null)
		{
			for (int i=0; i<ackArray.length; i++)
			{
				if (ackArray[i] == 0)
					bytesSent += chunkSize;
				else {
					startChunk = i;
					break;
				}
			}
			startAddress = bytesSent;
		} else {
			startChunk = 0;
			startAddress = 0;
			int numChunks = (otaData.length - startAddress) / chunkSize + (otaData.length % chunkSize == 0 ? 0 : 1);
			ackArray = new int[numChunks];

			for (int i=0; i<numChunks; i++)
				ackArray[i] = -1;
		}
		
		
		ByteArrayBuffer data = new ByteArrayBuffer(chunkSize);
		
		int numChunksLength = Utils.CHUNK_NUM_LENGTH_16;
//		int numChunksSize = Utils.CHUNK_NUM_LENGTH_8;
		
		int chunkNum = 0;
		
		while (startAddress + (chunkNum * chunkSize) < otaData.length && !breakDownload)
		{
			//add code to check if the ackArray status is OK, then skip this send
            int absChunk = startChunk + chunkNum;
            if (ackArray[absChunk] == 0)
            {
                Log.d(TAG, "skipping chunk number: " + absChunk);
                chunkNum++;
                continue;
            }
			data.clear();
			int len = otaData.length - (startAddress + (chunkNum * chunkSize));
			data.append(otaData, startAddress + (chunkNum * chunkSize) , len < chunkSize ? len : chunkSize);	
			bundle.putByteArray(Utils.STR_CHUNK_NUM, Utils.toBytes(chunkNum, numChunksLength));
			Log.d(TAG, "sending OTA chunk number: " + absChunk);
			chunkNum++;
			bundle.putByteArray(Utils.STR_OTA_UPDATE_DATA, data.buffer());
			bundle.putInt(Utils.STR_PREFERRED_CHUNK_SIZE, chunkSize);
			if (numChunksLength == Utils.CHUNK_NUM_LENGTH_16)
				success = downloadChunk16(bundle);
			else 
				success = downloadChunk8(bundle);
			if (!success)
				return false;
			try {
				synchronized(fotaObject){
					fotaObject.wait(200);
		        }
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return false;
			}
		}
		
		sentComplete = true;	
		
		mHandler.postDelayed(mCheckAckArray, checkAckArrayInterval);
	    
		return true;
	}
		
	private Runnable mCheckAckArray = new Runnable() {
        @Override
        public void run() {
        	boolean resend = true;
        	boolean resetArray = true;
        	boolean done = checkAckCompleteness(resend, resetArray);
        	if (done)
        	{
        		downloadComplete();
        		mHandler.removeCallbacks(mCheckAckArray);
        	} else {
        		mHandler.postDelayed(mCheckAckArray, checkAckArrayInterval);
        	}
        }
    };
	
	public boolean downloadChunk16(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_DOWNLOAD_CHUNK_16;
		
		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE);
		
		int[] itemsLengths = {CMD_LEN, Utils.CHUNK_NUM_LENGTH_16, chunkSize};
		String[] items = {Utils.STR_COMMAND, Utils.STR_CHUNK_NUM, Utils.STR_OTA_UPDATE_DATA};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
//		if (b)
//			startTimer(command);
		
		return b;
	}
	
	public boolean downloadChunk8(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_DOWNLOAD_CHUNK_8;
		
		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE);
		
		int[] itemsLengths = {CMD_LEN, Utils.CHUNK_NUM_LENGTH_8, chunkSize};
		String[] items = {Utils.STR_COMMAND, Utils.STR_CHUNK_NUM, Utils.STR_OTA_UPDATE_DATA};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
//		if (b)
//			startTimer(command);
		
		return b;
	}
	
	public boolean downloadComplete() {
		
		Bundle params = new Bundle();

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_DOWNLOAD_COMPLETE;
		
		params.putByte(Utils.STR_COMMAND, command);
		
		int[] itemsLengths = {CMD_LEN};
		String[] items = {Utils.STR_COMMAND};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}


    public boolean getIV() {

        Bundle params = new Bundle();

        byte cmd = Utils.ENUM_CMD_GET_IV;
        byte command = 0;

        params.putByte(Utils.STR_COMMAND, command);

        int[] itemsLengths = {CMD_LEN};
        String[] items = {Utils.STR_COMMAND};

        ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, false);

        if (data == null)
            return false;

        boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);

        return b;
    }


	public boolean onInstallRequest() {
		
		Bundle params = new Bundle();

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_INSTALL_REQUEST;
		
		params.putByte(Utils.STR_COMMAND, command);
		
		int[] itemsLengths = {CMD_LEN};
		String[] items = {Utils.STR_COMMAND};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}
	
	public boolean onResendChunk(Bundle params) {

		return downloadChunk16(params);
	}

	public boolean agreeOnKey(Bundle params) {
		byte cmd = Utils.ENUM_CMD_KDF;
		
		int[] itemsLengths = {Utils.BLE_ASSOCIATION_ID_LENGTH};
		String[] items = {Utils.STR_BLE_ASSOCIATION_ID};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, (byte)0, itemsLengths, items, false);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}


	public boolean getCommunicationVersion(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GET_COMMUNICATION_VERSION;
		byte command = (byte)0;
		
		int[] itemsLengths = {CMD_LEN};
		String[] items = {Utils.STR_COMMAND};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, false);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}
	
	public boolean getDeviceInfo(Bundle params) {
		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_GET_DEVICE_INFO;
		
		int[] itemsLengths = {CMD_LEN};
		String[] items = {Utils.STR_COMMAND};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}
	
	public boolean getErrors(Bundle params) {
		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_GET_ERRORS;
		
		int[] itemsLengths = {CMD_LEN, Utils.GET_ERRORS_COMMAND_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_GET_ERRORS_COMMAND};
		
		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, BleUtils.mActiveIndex);
		
		return b;
	}
	

	//***RESPONSE BUNDLES TO RETURN TO THE APP

	// implementation of calls from handleResponse to generate a bundle to the
	// interface
	
	private Bundle getBundleFromBuffer(int first, byte[] data, int[] itemsLengths, String[] items)
	{
		Bundle bundle = new Bundle();
		int length = 0;
		
		int start = first;
		int end = start + itemsLengths[0];
		
		for (int i=0; i < items.length; i++)
		{
			byte[] current = Arrays.copyOfRange(data, start, end);
			
			if (!items[i].equals(Utils.STR_IGNORE_VALUE)) {
				if (end - start > 1)
					bundle.putByteArray(items[i], current);
				else
					bundle.putByte(items[i], current[0]);
			}
			
			if (i < items.length -1) {
				if (itemsLengths[i] != Utils.PREV_VALUE_IS_LENGTH)
					start += itemsLengths[i];
				else 
					start += length;
				
				
				if (itemsLengths[i + 1] != Utils.PREV_VALUE_IS_LENGTH)
					end = start + itemsLengths[i + 1];
				else {
					length = this.fromByteArray(current);
					end = start + length;
				}
								
			}
		}

		return bundle;
	}
	
//	private Bundle getPublicKeyBundle(byte[] data) {
//		int[] itemsLengths = {Utils.PUBLIC_KEY_LENGTH, Utils.ECDSA_PUBLIC_KEY_LENGTH, Utils.IV_LENGTH};
//		String[] items = {Utils.STR_PUBLIC_KEY, Utils.STR_ECDSA_PUBLIC_KEY, Utils.STR_IV};
//		
//		Bundle bundle = getBundleFromBuffer(0, data, itemsLengths, items);
//		
//		byte[] iv = bundle.getByteArray(Utils.STR_IV);
//		byte[] remoteAES = bundle.getByteArray(Utils.STR_PUBLIC_KEY);
//		byte[] remoteECDSA = bundle.getByteArray(Utils.STR_ECDSA_PUBLIC_KEY);
//		
//		SecUtils.initSecurityParamsForSession(iv, remoteAES, remoteECDSA);
//		
////		mHandler.sendEmptyMessage(Utils.ENUM_CMD_HANDSHAKE1);
//
//		return bundle;
//	}
//
//	private Bundle getHandshakeBundle(byte[] data) {
//		int[] itemsLengths = {Utils.BLE_SIGNATURE_LENGTH};
//		String[] items = {Utils.STR_BLE_SIGNATURE};
//		
//		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);
//
//		return bundle;
//	}
	
//	private Bundle getKdfResponseBundle(byte[] data) {
//		int[] itemsLengths = {Utils.IV_LENGTH, Utils.BLE_SIGNATURE_LENGTH, Utils.DEVICE_STATUS_LENGTH};
//		String[] items = {Utils.STR_IV, Utils.STR_BLE_SIGNATURE, Utils.STR_DEVICE_STATUS};
//		
//		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);
//		
//		byte[] iv = bundle.getByteArray(Utils.STR_IV);
//		SecUtils.setNextIv(iv);
//		
//		byte status = bundle.getByte(Utils.STR_DEVICE_STATUS);
//
//		return bundle;
//		
//	}
	
	private Bundle getOnSuccessBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH};
		String[] items = {Utils.STR_COMMAND};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnExplicitSuccessBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH};
		String[] items = {Utils.STR_COMMAND};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnErrorBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH, Utils.ERROR_CODE_TYPE_LENGTH, Utils.ERROR_CODE_DETAIL_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ERROR_CODE_TYPE, Utils.STR_ERROR_CODE_DETAIL};
		
		Bundle bundle = getBundleFromBuffer(0, data, itemsLengths, items);

		return bundle;
	}

	private Bundle getOnOpStatusBundle(byte[] data) {
		Bundle bundle = new Bundle();

		int start = 0;
		int end = Utils.COMMAND_LENGTH;
		byte[] command = Arrays.copyOfRange(data, start, end);
		start += Utils.COMMAND_LENGTH;
		end = start + Utils.TYPE_ID_LENGTH;
		byte[] typeId = Arrays.copyOfRange(data, start, end);
		start += Utils.TYPE_ID_LENGTH;
		end = start + Utils.STATUS_VALUE_LENGTH;
		byte[] valueLen = Arrays.copyOfRange(data, start, end);
		if (valueLen[0] == 0)
			return null;
		int bValueLen = valueLen[0];
		start += Utils.STATUS_VALUE_LENGTH;
		end = start + bValueLen;
		byte[] value = Arrays.copyOfRange(data, start, end);

		bundle.putByteArray(Utils.STR_COMMAND, command);
		bundle.putByteArray(Utils.STR_STATUS_TYPE_ID, typeId);
		bundle.putByteArray(Utils.STR_STATUS_VALUE_LENGTH, valueLen);
		bundle.putByteArray(Utils.STR_STATUS_VALUE, value);

		return bundle;
	}
	
	private Bundle getOnGetCommVersionResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DEVICE_CODE_VERSION_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH};
		String[] items = {Utils.STR_IGNORE_VALUE, Utils.STR_COMMUNICATION_VERSION};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}

    private Bundle getOnGetIvResponseBundle(byte[] data) {
        int[] itemsLengths = {Utils.IV_LENGTH};
        String[] items = {Utils.STR_IV};

        Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

        return bundle;
    }
	
	private Bundle getOnGetDeviceInfoResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DEVICE_ID_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH, Utils.DEVICE_MODEL_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH, 
				Utils.DEVICE_CODE_VERSION_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH, Utils.DEVICE_UPDATE_STATUS_LENGTH};
		String[] items = {Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_ID, Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_MODEL, 
				Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_CODE_VERSION, Utils.STR_DEVICE_UPDATE_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadParamsResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.PREFERRED_START_ADDRESS_LENGTH, Utils.PREFERRED_CHUNK_SIZE_LENGTH, Utils.IV_LENGTH};
		String[] items = {Utils.STR_PREFERRED_START_ADDRESS, Utils.STR_PREFERRED_CHUNK_SIZE, Utils.STR_IV};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadCompleteResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DOWNLOAD_COMPLETE_STATUS_LENGTH, Utils.DP_CONTENT_LENGTH};
		String[] items = {Utils.STR_DOWNLOAD_COMPLETE_STATUS, Utils.STR_DP_CONTENT};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnInstallStatusBundle(byte[] data) {
		int[] itemsLengths = {Utils.INSTALL_STATUS_LENGTH};
		String[] items = {Utils.STR_INSTALL_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadChunkStatusBundle(byte[] data) {
		int[] itemsLengths = {Utils.CHUNK_NUM_LENGTH_16, Utils.DOWNLOAD_CHUNK_STATUS_LENGTH};
		String[] items = {Utils.STR_CHUNK_NUM, Utils.STR_DOWNLOAD_CHUNK_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);
		
		byte status = bundle.getByte(Utils.STR_DOWNLOAD_CHUNK_STATUS);
		byte[] num = bundle.getByteArray(Utils.STR_CHUNK_NUM);
		int chunkNumber = Utils.toInt(num);
		ackArray[startChunk + chunkNumber] = status;
		int curUpdate = startChunk + chunkNumber;
		Log.d(TAG, "chunk number: " + curUpdate + " status: " + status);
        if (status > 0)
        {
            breakDownload = true;
            mHandler.removeCallbacks(mCheckAckArray);
        }
		
		// check if all chunks have been sent successfully
		
//		if (sentComplete)
//		{
//			boolean resend = true;
//			boolean resetArray = true;
//			if (checkAckCompleteness(resend, resetArray))
//			{
//				mHandler.removeCallbacks(mCheckAckArray);
//				downloadComplete();
//			}
//		}
		return bundle;
	}
	
	private Bundle getOnGetErrorsResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.GET_ERRORS_DATA_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH};
		String[] items = {Utils.STR_IGNORE_VALUE, Utils.STR_GET_ERRORS_RESPONSE_DATA};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private boolean checkAckCompleteness(boolean resend, boolean resetArray)
	{		
		for (int i=0; i<ackArray.length; i++)
		{
			if (ackArray[i] != 0)
			{
				if (resend)
				{
					Bundle bundle = new Bundle();
					bundle.putByte(Utils.STR_DOWNLOAD_CHUNK_STATUS, (byte)5);//5 = other error
					
					byte[] num = Utils.toBytes(i, 2);
					bundle.putByteArray(Utils.STR_CHUNK_NUM, num);
					//this will cause the application to resend the chunk
					ble_interface.onDownloadChunkStatus(bundle);
				}
				return false;
			}
		}
		if (resetArray)
			ackArray = null;
		return true;	
	}
	

}
