

package com.multlock.key;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;

import org.apache.http.util.ByteArrayBuffer;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.ParcelUuid;
import android.util.Log;
import android.util.SparseArray;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class BleUtils extends AsyncTask<Bundle, Void, Boolean> implements BluetoothAdapter.LeScanCallback {

	
	// 7-6	- bat state	00=full, 10=mid, 01=low, 11=is a not valid state
	// 5	- charge	0 = not charging
	// 4	- door	0 = closed
	// 3	- lock	0 = locked
	// 2	- mute	0 = not muted
	// 1	- Auto	0 = auto
	// 0	- Always 1
	
	public class bleDevice {		
		public BluetoothDevice device;
		private int rssi;
		private byte lockState;
		private byte deviceStatus;
		private byte batteryPercent;
		private BluetoothGatt mConnectedGatt = null;
		public byte getLockState() { return lockState;}
		public byte getBatteryPercents() { return batteryPercent;}
		public void setBatteryPercents(byte percents) { batteryPercent = percents;}
		public byte getDeviceStatus () { return deviceStatus;}
		public void setDeviceStatus (byte status) { deviceStatus = status;}
	}
	
	public class lockKeyData {
		public int role; //user, admin, owner
		public byte[] user;
		public int state; //enabled, disabled
	}
	
	public static ArrayList<lockKeyData> lockKeysList = new ArrayList<lockKeyData>();

	private static final String TAG = "MTLT_BLE";
	public static final int KNOWN_DEVICES_SCAN_INTERVAL = 2500;
	private static final byte LOCAL_PAYLOAD = 0;
	private static final byte PRIMARY_PAYLOAD = 1;
	private static final byte SECONDARY_PAYLOAD = 2;

	private static ByteArrayBuffer primaryPayloadAccumulation = new ByteArrayBuffer(256);
	private ByteArrayBuffer secondaryPayloadAccumulation = new ByteArrayBuffer(256);
	private static int primaryCommand = 0;
	private static int secondaryCommand = 0;
	private int primaryExpectedChksum = 0;
	private static int secondaryExpectedChksum = 0;
	private static int primaryExpectedLength = 0;
	private static int secondaryExpectedLength = 0;
	private int primaryAccumulatedLength = 0;
	private static int secondaryAccumulatedLength = 0;
	private static byte primaryCounter = 0;
	private static byte secondaryCounter = 0;

	// length of values for control and payload
	private final int CMD_LEN = 1;
	private final int PAYLOAD_LOCATION_LEN = 1;
	private final int DATA_LENGHT_LEN = 2;
	private final int CHKSUM_LEN = 1;
	private final int COUNTER_LEN = 1;
	private final int PAYLOAD_LENGTH_LEN = 1;

	// location in byte[] of information in Control
	private final int CTRL_CMD_LOCATION = 0;
	private final int CTRL_PAYLOAD_TYPE_LOCATION = CMD_LEN;
	private final int CTRL_PAYLOAD_LENGTH_LOCATION = CTRL_PAYLOAD_TYPE_LOCATION + PAYLOAD_LOCATION_LEN;
	private final int CTRL_PAYLOAD_CHKSUM_LOCATION = CTRL_PAYLOAD_LENGTH_LOCATION + DATA_LENGHT_LEN;
	private final int CTRL_HEADER_CHKSUM_LOCATION = CTRL_PAYLOAD_CHKSUM_LOCATION + CHKSUM_LEN;
	private final int CTRL_PAYLOAD_LOCATION = CTRL_HEADER_CHKSUM_LOCATION + CHKSUM_LEN;

	// location in byte[] of information in Payload
	private final int PAYLOAD_COUNTER_LOCATION = 0;
	private final int PAYLOAD_LENGTH_LOCATION = PAYLOAD_COUNTER_LOCATION + COUNTER_LEN;
	private final int PAYLOAD_DATA_LOCATION = PAYLOAD_LENGTH_LOCATION + COUNTER_LEN;

	/* MulTLock Command Service */
	/* UUIDs generated by def */
	private static final UUID GENERIC_SERVICE = UUID.fromString("c5e01900-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID REQUEST_SERVICE = UUID.fromString("c5e00100-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID REQUEST_CHAR_CONTROL = UUID.fromString("c5e00101-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID REQUEST_CHAR_PAYLOAD = UUID.fromString("c5e00102-d396-11e3-bb18-0002a5d5c51b");

	private static final UUID RESPONSE_SERVICE = UUID.fromString("c5e00200-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID RESPONSE_CONTROL = UUID.fromString("c5e00201-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID RESPONSE_PRIMARY = UUID.fromString("c5e00202-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID RESPONSE_SECONDARY = UUID.fromString("c5e00203-d396-11e3-bb18-0002a5d5c51b");
	private static final UUID RESPONSE_GENERAL_STATUS = UUID.fromString("c5e00204-d396-11e3-bb18-0002a5d5c51b");

	private static final UUID CONFIG_DESCRIPTOR = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

	private static final UUID[] serviceUuids = { REQUEST_SERVICE };

	private static final int MAX_PAYLOAD_BUFFER = 18;
	private static final int MAX_LOCAL_PAYLOAD_BUFFER = 14;


	private ByteArrayBuffer controlBuffer;
	private ByteArrayBuffer payloadBuffer;

	private static BluetoothGattService cmdService;
	private static BluetoothGattService resService;
	private Context context;
	private byte[] lastReq;
	private byte[] lastRes;
	private BluetoothAdapter mBluetoothAdapter;
	private Bundle pendingBundle;
	private boolean pendingSetOwner = false;
	private boolean pendingNewKey = false;
	private int ACK_SLEEP_TIME = 0;
	
	private final boolean securityOn = true;
	
	private final int rssiLimit = -90;
	
	private long startTime, endTime, diffTime;
	private boolean useFOTASecurity = true;
	private FotaBleUtils fota = null;
	boolean fotaSupported = true;
	


	//private static ArrayList<ArrayList<bleDevice>> bleDevices = new ArrayList<ArrayList<bleDevice>>(2);
	
	class DeviceLists extends ArrayList<bleDevice> {

	}

	private static DeviceLists[] bleDevices = new DeviceLists[2];
	//private static List<List<bleDevice>> bleDevices = new ArrayList<List<bleDevice>>(2);

	private static int currentFinal = 1;
	private static int currentTemp = 0;

	public static BluetoothGatt mActiveGatt = null;
	public static int mActiveIndex = -1;
	private static BluetoothDevice device = null;
	private BleInterface ble_interface;
	private static int scanTime = KNOWN_DEVICES_SCAN_INTERVAL;
	private static int waitTime = KNOWN_DEVICES_SCAN_INTERVAL;

	private long time_before, time_after;
	public static int write_count = 0;
	private Handler mHandler;

	private int mState = 0;
	private boolean stateConnected = false;
	private boolean scanFreeze = false;
	
	private final byte AUTO_BIT_VALUE = 2;
	private final byte MUTE_BIT_VALUE = 4;
	private final byte LOCK_BIT_VALUE = 8;
	private final byte DOOR_BIT_VALUE = 16;
	private final byte CHARGE_BIT_VALUE = 32;
	private final byte BATTERY_BIT_VALUE_LOW = 64;
	private final byte BATTERY_BIT_VALUE_HIGH = -128;
	private static final int BATTERY_MED_FULL_LIMIT = 20;
	private static final int BATTERY_LOW_MED_LIMIT = 10;
	
	public boolean isLockAutoLocked(byte status) { return (status & AUTO_BIT_VALUE) == 0; }
	public boolean isLockMuted(byte status) { return (status & MUTE_BIT_VALUE) > 0; }
	public boolean isLockLocked(byte status) { return (status & LOCK_BIT_VALUE) == 0; }
	public boolean isDoorLocked(byte status) { return (status & DOOR_BIT_VALUE) == 0; }
	
	public boolean isLockLocked(boolean finalList, int i) 
	{ 
		int listID = (finalList ? currentFinal : currentTemp);
		byte status = bleDevices[listID].get(i).getDeviceStatus();
		return isLockLocked(status); 
	}
	
	public boolean isDoorClosed(byte status) { return (status & DOOR_BIT_VALUE) == 0; }
	public boolean isLockCharging(byte status) { return (status & CHARGE_BIT_VALUE) > 0; }
	public int getBatteryState(byte status) { 
		int t1 = ((status & BATTERY_BIT_VALUE_LOW) == 0 ? 0 : 1);
		int t2 = ((status & BATTERY_BIT_VALUE_HIGH) == 0 ?  0 : 1);
		int state = t1 + 2 * t2;
		Log.d(TAG, "Battery Status:  " + state);
		switch (state) {
		case 1: return Utils.BATTERY_STATE_LOW;
		case 2: return Utils.BATTERY_STATE_MEDIUM;
		case 0: return Utils.BATTERY_STATE_HIGH;
		default:
			break;
		}
		return -1;
	}
	
	public static int getBatteryStateFromPercents(byte percents) { 
		if (percents <= BATTERY_LOW_MED_LIMIT)
			return Utils.BATTERY_STATE_LOW;
		if (percents < BATTERY_MED_FULL_LIMIT)
			return Utils.BATTERY_STATE_MEDIUM;
		if (percents <= 100)
			return Utils.BATTERY_STATE_HIGH;
		return -1;
	}
	
	private String batteryString(int state)
	{
		switch (state) {
		case 1: return "MEDIUM";
		case 2: return "HIGH";
		case 0: return "LOW";
		default:
			break;
		}
		return "ILLEGAL";
	}
	
	private int fromByteArray(byte[] bytes) {
		int res = 0;
		for (int i = 0; i < bytes.length; i++)
			res = res * 2 + bytes[i];
		
	     return res;
	}

	private void reset() {
		mState = 0;
		enableDone = false;
	}

	public void advance() {
		mState++;
	}

	boolean enableDone = false;
	
	private Handler timerHandler = new Handler() {
	    @Override
	    public void handleMessage(Message msg) {
	    	ble_interface.onTimerExpired(msg.what);
	    }
	};
	
	private int WAIT_FOR_RESPONSE_INTERVAL = 1000;
	
	private void startTimer(int command)
	{
		Log.d(TAG, "Starting timer for command: " + command);
//		Message msg = timerHandler.obtainMessage(command);
//		timerHandler.sendMessageDelayed(msg, WAIT_FOR_RESPONSE_INTERVAL);
	}
	
	private void stopTimer(int command)
	{
		Log.d(TAG, "Stopping timer for command: " + command);
//		timerHandler.removeMessages(command);
	}

	public static Object object = new Object();

	public void setControlProfile(int index, byte cmd, byte pl_location, short len, byte payload_chksum, byte[] data) {
		if (index < 0)
			return;
		//mActiveGatt = this.getGattFromId(index);
		mActiveIndex = index;
		if (mActiveGatt == null)
			return;
		byte[] tmp1 = new byte[1];
		tmp1[0] = cmd;

		controlBuffer.clear();
		
		controlBuffer.append(tmp1, 0, CMD_LEN);// command
		
		byte[] tmp2 = new byte[2];
		tmp1[0] = pl_location;
		controlBuffer.append(tmp1, 0, PAYLOAD_LOCATION_LEN);// payload location
															// - local, primary,
															// secondary
		tmp2[0] = (byte) (len & 0xff);
		tmp2[1] = (byte) ((len >> 8) & 0xff);
		controlBuffer.append(tmp2, 0, DATA_LENGHT_LEN);// payload size
		tmp1[0] = payload_chksum;// checksum of total payload
		controlBuffer.append(tmp1, 0, CHKSUM_LEN);// payload checksum
		tmp1[0] = (byte) calculateChecksum(0, CTRL_HEADER_CHKSUM_LOCATION, controlBuffer.buffer());// checksum
																									// of
																									// current
																									// data
		controlBuffer.append(tmp1, 0, CHKSUM_LEN);// control checksum
		if (data != null)
			controlBuffer.append(data, 0, data.length);// data

	}

	public boolean sendPayload(byte[] data) {
		if (mActiveGatt == null)
			return false;
		boolean b;
		byte count = 1;
		int total_length = data.length;
		int left_length = total_length;
		BluetoothGattCharacteristic characteristic = cmdService.getCharacteristic(REQUEST_CHAR_PAYLOAD);
		characteristic.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
										// 2=DEFAULT;4=WRITE_TYPE_SIGNED

		int accumulatedOffset = 0;
		byte[] tmp1 = new byte[1];

		while (left_length > 0) {
			payloadBuffer.clear();
			tmp1[0] = (left_length > MAX_PAYLOAD_BUFFER ? count++ : (byte) (0xFE | count));
			payloadBuffer.append(tmp1, 0, COUNTER_LEN);
			int len = (left_length < MAX_PAYLOAD_BUFFER ? (byte) left_length : (byte) MAX_PAYLOAD_BUFFER);
			tmp1[0] = (byte) len;// calculateChecksum(accumulatedOffset, len,
									// data);
			payloadBuffer.append(tmp1, 0, PAYLOAD_LENGTH_LEN);
			payloadBuffer.append(data, accumulatedOffset, len);
			accumulatedOffset += len;
			try {
				// wait for previous write to end
				synchronized (object) {
					long time1 = System.currentTimeMillis();
					object.wait(200);
					long time2 = System.currentTimeMillis();
					long delta = time2 - time1;
					Log.i(TAG, "payload waiting time: " + delta);

				}
				Thread.sleep(5);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalMonitorStateException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			b = characteristic.setValue(payloadBuffer.buffer());
			if (!b)
				return false;
			// time_before = System.currentTimeMillis();
			if (mActiveGatt == null)
				return false;
			b = mActiveGatt.writeCharacteristic(characteristic);
			if (!b)
				return false;

			// for test
			// this.handlePayloadResponse(payloadBuffer.buffer(), true);

			left_length -= MAX_PAYLOAD_BUFFER;
		}
		return true;
	}
	
	private boolean sendCommand(byte command, ByteArrayBuffer data, int connectionIndex)
	{
		// no length and IV - use data
		
		int index = connectionIndex;
		
		byte chksum = calculateChecksum(0, data.length(), data.toByteArray());

		if (data.length() <= BleUtils.MAX_LOCAL_PAYLOAD_BUFFER)
			setControlProfile(index, command, LOCAL_PAYLOAD, (short) data.length(), (byte) chksum, data.buffer());
		else
			setControlProfile(index, command, PRIMARY_PAYLOAD, (short) data.length(), (byte) chksum, null);

		boolean b = sendControl(controlBuffer.buffer());
		if (!b)
			return false;

		if (data.length() > BleUtils.MAX_LOCAL_PAYLOAD_BUFFER)
			return sendPayload(data.buffer());
		else
			return true;
	}

	private boolean handleControlResponse(byte[] data) {
		Bundle bundle = null;

		int control_chksum = getControlChksumFromResponse(data);
		if (!verifyChecksum(5, data, control_chksum)) {
			Log.e(TAG, "Checksum error");
			return false;
		}
		int cmd = getCommandFromResponse(data);
		
		int payload_location = getPayloadLocationFromResponse(data);
		int expectedLength = getPayloadLengthFromResponse(data);
		int expectedChksum = getPayloadChksumFromResponse(data);

		if (payload_location == LOCAL_PAYLOAD) {
			// get payload from control
			byte[] payload = null;
			if (expectedLength > 0)
				payload = getPayloadFromResponse(data, expectedLength);
			
			boolean bRC = handlePayloadContent(payload, cmd);
			
			if (!bRC)
				return false;

		} else {
			if (payload_location == PRIMARY_PAYLOAD) {
				// payload in primary response
				primaryCommand = cmd;
				primaryExpectedChksum = expectedChksum;
				primaryExpectedLength = expectedLength;
				primaryAccumulatedLength = 0;
				primaryCounter = 0;
				this.primaryPayloadAccumulation.clear();
			} else {
				// payload in secondary response
				secondaryCommand = cmd;
				secondaryExpectedChksum = expectedChksum;
				secondaryExpectedLength = expectedLength;
				secondaryAccumulatedLength = 0;
				secondaryCounter = 0;
				this.secondaryPayloadAccumulation.clear();
			}
		}
		return true;
	}

	private boolean handlePayloadResponse(byte[] data, boolean isPrimaryData) {
		Bundle bundle = null;
		int cmd;

		BluetoothGattCharacteristic characteristic;
		ByteArrayBuffer buffer;
		int count = getCounterFrompayload(data);

		// int chksum = getChksumFromPayloadResponse(data);
		// if (!verifyChecksum(data.length, data, chksum))
		// return false;
		boolean isLast;
		if (isPrimaryData) {
			isLast = isLastBuffer(data, ++primaryCounter);
			if (primaryCounter != count && !isLast) {
				return false;
			}
			characteristic = cmdService.getCharacteristic(this.RESPONSE_PRIMARY);
			buffer = this.primaryPayloadAccumulation;
			cmd = primaryCommand;
//			if (count == 1)
//				buffer.clear();
		} else {
			isLast = isLastBuffer(data, ++secondaryCounter);
			if (secondaryCounter != count && !isLast) {
				return false;
			}
			characteristic = cmdService.getCharacteristic(this.RESPONSE_SECONDARY);
			buffer = this.secondaryPayloadAccumulation;
			cmd = secondaryCommand;
			if (count == 1)
				buffer.clear();
		}
		int length = getPayloadLengthFromPayloadResponse(data);

		buffer.append(data, PAYLOAD_DATA_LOCATION, length);
		this.primaryAccumulatedLength += length;
		if (isLast) {
			boolean b = this.verifyChecksum(primaryAccumulatedLength, buffer.buffer(), this.primaryExpectedChksum);
			if (!b) {
				Log.e(TAG, "checksum error");
				return false;
			}
			
			ByteArrayBuffer payload = new ByteArrayBuffer(primaryAccumulatedLength);
			payload.append(buffer.buffer(), 0, primaryAccumulatedLength);
			
			//future use - merge code to handle cases
			b = handlePayloadContent(payload.buffer(), cmd);
		}
		return true;
	}
	
	private boolean handlePayloadContent(byte[] payload, int cmd)
	{
		Bundle bundle = null;
		int expCommand = 0;
		
		Log.d(TAG, "in handlePayloadContent - command " + cmd);
		
		switch (cmd) {
		
		case Utils.ENUM_CMD_SEND_PUBLIC_KEY:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_SEND_PUBLIC_KEY ");
			bundle = getPublicKeyBundle(payload);
			ble_interface.onSendPublicKeyResponse(bundle);
			expCommand = cmd;
			break;
		case Utils.ENUM_CMD_OP_SUCCESS_IMP:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_OP_SUCCESS_IMP ");
			ble_interface.onLastRequestSuccess();
			break;
		case Utils.ENUM_CMD_OP_SUCCESS_EXP:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_OP_SUCCESS_EXP ");
			bundle = getOnSuccessBundle(payload);
			ble_interface.onRequestSuccess(bundle);
			expCommand = bundle.getByte(Utils.STR_COMMAND);
			break;
		case Utils.ENUM_CMD_OP_ERROR:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_OP_ERROR ");
			bundle = getOnErrorBundle(payload);
			ble_interface.onRequestError(bundle);
			expCommand = bundle.getByte(Utils.STR_COMMAND);
			break;
		case Utils.ENUM_CMD_OP_STATUS:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_OP_STATUS ");
			bundle = getOnOpStatusBundle(payload);
			if (bundle != null)
				ble_interface.onStatusResponse(bundle);
			break;
		case Utils.ENUM_CMD_GET_COMMUNICATION_VERSION_RESPONSE:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GET_COMMUNICATION_VERSION_RESPONSE ");
			bundle = getOnGetCommVersionResponseBundle(payload);
			if (bundle != null)
				ble_interface.onGetCommVersionResponse(bundle);
			expCommand = Utils.ENUM_CMD_GET_COMMUNICATION_VERSION;
			break;
		case Utils.ENUM_CMD_GENERAL_ENCRYPTED:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GENERAL_ENCRYPTED ");
			// decrypt buffer
			startTime = System.currentTimeMillis();
			payload = getDecryptedData(payload);
			endTime = System.currentTimeMillis();
			Log.i(TAG, "*** After Decrypt - duration = " + (endTime - startTime));
			if (payload == null)
				return false;
			//this.handlePayloadResponse(clearData, true); - commented out last fix
		case Utils.ENUM_CMD_GENERAL_PLAIN:
			Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GENERAL_PLAIN ");
			int internalCmd = payload[Utils.EXPLICIT_SUCCESS_COMMAND_LOCATION];
			switch (internalCmd) {
				case Utils.ENUM_CMD_OP_SUCCESS_EXP:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_OP_SUCCESS_EXP ");
					bundle = getOnExplicitSuccessBundle(payload);
					ble_interface.onRequestSuccess(bundle);
					expCommand = bundle.getByte(Utils.STR_COMMAND);
					break;
				case Utils.ENUM_CMD_GET_DEVICE_CONFIG_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GET_DEVICE_CONFIG_RESPONSE ");
					bundle = getDeviceConfigResponseBundle(payload);
					try {
						Thread.sleep(ACK_SLEEP_TIME);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					mHandler.sendEmptyMessage(Utils.ENUM_CMD_GET_DEVICE_CONFIG_RESPONSE_ACK);
//					sendAck(Utils.ENUM_CMD_GET_DEVICE_CONFIG_RESPONSE_ACK);
					ble_interface.onGetDeviceConfigResponse(bundle);
					if (mActiveIndex > -1)
					{
						bleDevice ble = bleDevices[currentFinal].get(mActiveIndex);
						if (ble != null) {
							ble.setBatteryPercents(payload[2]);
							ble.setDeviceStatus(payload[1]);
						}
					}
					expCommand = Utils.ENUM_CMD_GET_DEVICE_CONFIG;
					break;
					
				case Utils.ENUM_CMD_HANDSHAKE1:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_HANDSHAKE1 ");
					bundle = getHandshakeBundle(payload);
					ble_interface.onHandshakeResponse(bundle);
					ble_interface.onBleReady2Comm(bundle);
					expCommand = Utils.ENUM_CMD_HANDSHAKE1;
					break;
				case Utils.ENUM_CMD_KDF_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_KDF_RESPONSE ");
					bundle = getKdfResponseBundle(payload);
					ble_interface.onKdfResponse(bundle);
					ble_interface.onBleReady2Comm(bundle);
					expCommand = Utils.ENUM_CMD_KDF;
					break;
				case Utils.ENUM_CMD_SET_OWNER_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_SET_OWNER_RESPONSE ");
					pendingSetOwner = true;
					try {
						Thread.sleep(ACK_SLEEP_TIME);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					pendingBundle = getSetOwnerResponseBundle(payload);
					mHandler.sendEmptyMessage(Utils.ENUM_CMD_SET_OWNER_ACK);
					Log.d(TAG, "calling onSetOwnerResponse");
					//ble_interface.onSetOwnerResponse(bundle);
					expCommand = Utils.ENUM_CMD_SET_OWNER;
					break;
				case Utils.ENUM_CMD_GET_NEW_KEY_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GET_NEW_KEY_RESPONSE ");
					pendingNewKey = true;
					try {
						Thread.sleep(ACK_SLEEP_TIME);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					mHandler.sendEmptyMessage(Utils.ENUM_CMD_GET_NEW_KEY_ACK);
					pendingBundle = getNewKeyResponseBundle(payload);
					Log.d(TAG, "calling onGetKeyResponse");
					//ble_interface.onGetNewKeyResponse(bundle);
					expCommand = Utils.ENUM_CMD_GET_NEW_KEY;
					break;
				case Utils.ENUM_CMD_GET_KEYS_RESPONSE:
					int keysLeft = getKeysResponseBundle(payload);
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GET_KEYS_RESPONSE ");
					if (keysLeft == 0)
						ble_interface.onGetKeysResponse(this.lockKeysList);
					else
						ble_interface.onGetKeysLeft(keysLeft);
					expCommand = Utils.ENUM_CMD_GET_KEYS;
					break;
				case Utils.ENUM_CMD_RECOVER_OWNER_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_RECOVER_OWNER_RESPONSE ");
					bundle = getRecoverOwnerResponseBundle(payload);
					Log.d(TAG, "calling onRecoverOwnerResponse");
					ble_interface.onRecoverOwnerResponse(bundle);
					expCommand = Utils.ENUM_CMD_RECOVER_OWNER;
					break;
//				case Utils.ENUM_CMD_GET_DEVICE_INFO_RESPONSE:
//					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_GET_DEVICE_INFO_RESPONSE ");
//					bundle = getOnGetDeviceInfoResponseBundle(payload);
//					if (bundle != null)
//						ble_interface.onGetDeviceInfoResponse(bundle);
//					expCommand = Utils.ENUM_CMD_GET_DEVICE_INFO;
//					break;
				case Utils.ENUM_CMD_DOWNLOAD_PARAMS_RESPONSE:
					Log.d(TAG, "in handlePayloadContent - ENUM_CMD_DOWNLOAD_PARAMS_RESPONSE ");
					bundle = getOnDownloadParamsResponseBundle(payload);
					if (bundle != null)
						ble_interface.onDownloadParamsResponse(bundle);
					expCommand = Utils.ENUM_CMD_DOWNLOAD_PARAMS_REQUEST;
					break;
//				case Utils.ENUM_CMD_DOWNLOAD_COMPLETE_RESPONSE:
//					bundle = getOnDownloadCompleteResponseBundle(payload);
//					if (bundle != null)
//						ble_interface.onDownloadCompleteResponse(bundle);
//					expCommand = Utils.ENUM_CMD_DOWNLOAD_COMPLETE;
//					break;
//				case Utils.ENUM_CMD_INSTALL_STATUS:
//					bundle = getOnInstallStatusBundle(payload);
//					if (bundle != null)
//						ble_interface.onInstallStatus(bundle);
//					expCommand = Utils.ENUM_CMD_INSTALL_REQUEST;
//					break;
//				case Utils.ENUM_CMD_DOWNLOAD_CHUNK_STATUS:
//					bundle = getOnDownloadChunkStatusBundle(payload);
//					if (bundle != null)
//						ble_interface.onDownloadChunkStatus(bundle);
//					expCommand = Utils.ENUM_CMD_INSTALL_REQUEST;
//					break;
					
				default:
					break;
			}
			break;
		default:
			break;
		}
		
		stopTimer(expCommand);
		
		return true;
	}
	
	private byte[] getDecryptedData(byte[] payload) {
//		byte[] iv = Arrays.copyOfRange(payload, 0, SecUtils.getIvLength());
//		byte[] len = Arrays.copyOfRange(payload, SecUtils.getIvLength(), SecUtils.getIvLength() + this.DATA_LENGHT_LEN);
//		int iLen = len[1] * 256 + len[0];
//		byte[] encData = Arrays.copyOfRange(payload, SecUtils.getIvLength() + this.DATA_LENGHT_LEN, SecUtils.getIvLength() + this.DATA_LENGHT_LEN + iLen);

		byte[] clearData = null;
		try {
//			clearData = SecUtils.decrypt(null, encData, iv);
			//payload is pure encryption
			clearData = SecUtils.decrypt(null, payload, null);
		} catch (GeneralSecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return clearData;
	}

	private boolean verifyChecksum(int length, byte[] data, int Checksum_To_Compare) {
		if (calculateChecksum(0, length, data) == Checksum_To_Compare)
			return true; // Checksum is correct, data is valid

		return false; // Error in checksum, data is invalid
	}

	private byte calculateChecksum(int offset, int length, byte[] data) {
		if (offset > data.length)
			return -1;
		if (length + offset > data.length)
			length = data.length - offset;
		int sum = 0;
		byte Calc_Checksum;

		for (int i = offset; i < offset + length; i++)
			sum += (data[i] >= 0 ? data[i] : data[i] + 256);

		String s = new String(data);

		Calc_Checksum = (byte) (sum >> 8);
		Calc_Checksum += sum;
		Calc_Checksum += 0xA0;

		return Calc_Checksum;
	}

	private int getCommandFromResponse(byte[] data) {
		return data[CTRL_CMD_LOCATION];
	}

	private int getPayloadLocationFromResponse(byte[] data) {
		return data[CTRL_PAYLOAD_TYPE_LOCATION];
	}

	private int getPayloadLengthFromResponse(byte[] data) {
		return ((int) data[CTRL_PAYLOAD_LENGTH_LOCATION + 1] << 8) | ((int) data[CTRL_PAYLOAD_LENGTH_LOCATION] & 0xFF);
	}

	private int getPayloadChksumFromResponse(byte[] data) {
		return data[CTRL_PAYLOAD_CHKSUM_LOCATION];
	}

	private int getControlChksumFromResponse(byte[] data) {
		return data[CTRL_HEADER_CHKSUM_LOCATION];
	}

	private byte[] getPayloadFromResponse(byte[] data, int size) {
		if (data == null)
			return null;
		return Arrays.copyOfRange(data, CTRL_PAYLOAD_LOCATION, CTRL_PAYLOAD_LOCATION + size);
	}

	private int getPayloadLengthFromPayloadResponse(byte[] data) {
		return data[PAYLOAD_LENGTH_LOCATION];
	}

	private boolean isLastBuffer(byte[] data, byte expected) {
		byte counter = data[0];
		byte expectedValue = (byte) ((byte) (0xFE) | expected);
		return (expectedValue == counter);
	}

	private int getCounterFrompayload(byte[] data) {
		byte counter = data[0];
		return (int) counter;
	}
	
	public boolean sendAck(byte ackFor) {
		boolean b;
		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte[] command = new byte[CMD_LEN];
		command[0] = ackFor;

		ByteArrayBuffer data = new ByteArrayBuffer(CMD_LEN);

		data.append(command, 0, CMD_LEN);
		
		//encrypt the data since moved to getBuffer
		byte[] tmpBuffer = null;
		if (this.securityOn)
		{
			try {
				tmpBuffer = SecUtils.encrypt(null, data.buffer(), null);
			} catch (GeneralSecurityException e) {
				e.printStackTrace();
			}
			if (tmpBuffer == null)
				return false;
		}
		
		data = new ByteArrayBuffer(tmpBuffer.length);
		data.append(tmpBuffer, 0, tmpBuffer.length);
		
		b = sendCommand(cmd, data, mActiveIndex);
		return b;
	}
	

	// implementation of calls from Application to send requests to BLE
	public boolean SendPublicKey(Bundle params) {
		boolean b;
		byte cmd = Utils.ENUM_CMD_SEND_PUBLIC_KEY;
		ByteArrayBuffer data = new ByteArrayBuffer(Utils.PUBLIC_KEY_LENGTH);
		//byte[] key = params.getByteArray(Utils.STR_KEY);
		byte[] key = SecUtils.getLocalPublicKey().getEncoded();
		data.append(key, key.length - Utils.PUBLIC_KEY_LENGTH, Utils.PUBLIC_KEY_LENGTH);
		
		// no need to encrypt the data 
		b = sendCommand(cmd, data, mActiveIndex);
		return b;
	}

	private boolean sendControl(byte[] message) {
		Boolean b;
		
		if (mActiveGatt == null)
			return false;
		
//		cmdService = mActiveGatt.getService(REQUEST_SERVICE);
//		if (cmdService == null)
//			return false;

		if (cmdService == null)
			return false;
		BluetoothGattCharacteristic characteristic = cmdService.getCharacteristic(REQUEST_CHAR_CONTROL);
		characteristic.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
										// 2=DEFAULT;4=WRITE_TYPE_SIGNED

		b = characteristic.setValue(message);
		if (!b)
			return false;

		b = mActiveGatt.writeCharacteristic(characteristic);
		long time2 = System.currentTimeMillis();
		Log.i(TAG, "control sending time: " + time2);
		if (!b)
			return false;

		return true;
	}
	
	private ByteArrayBuffer getBufferFromBundle(Bundle params, byte cmd, int[] itemsLengths, String[] items, boolean encrypted)
	{	
		int fullSize = 0;
		byte[] currentBytes = null;
		byte[] currentByte = new byte[1];
		byte[] command = new byte[CMD_LEN];
		
		for (int i=0; i<itemsLengths.length; i++)
			fullSize += itemsLengths[i];
		
		ByteArrayBuffer data = new ByteArrayBuffer(fullSize);
		
		for (int i=0; i<itemsLengths.length; i++)
		{
			String current = items[i];
			if (current.equals(Utils.STR_COMMAND)) {
				command[0] = cmd;
				currentBytes = command;
			} else {
				if (itemsLengths[i] > 1) {
					currentBytes = params.getByteArray(current);
				}
				else {
					currentByte[0] = params.getByte(current, (byte)0);
					currentBytes = currentByte;
				}
			} 			
			
			data.append(currentBytes, 0, itemsLengths[i]);
		}
		if (this.securityOn && encrypted)
			try {
				byte[] tmpBuffer = SecUtils.encrypt(null, data.buffer(), null);
				if (tmpBuffer == null)
					return null;
				
				//no IV - append only encrypted data
				data = new ByteArrayBuffer(tmpBuffer.length);
				data.append(tmpBuffer, 0, tmpBuffer.length);
			} catch (GeneralSecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
		return data;
	}
	
	public boolean handShake(Bundle params) {
		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_HANDSHAKE1;
		
		int[] itemsLengths = {CMD_LEN, Utils.APP_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_APP_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean setOwner(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_SET_OWNER;
		
		int[] itemsLengths = {CMD_LEN, Utils.PREV_ADMIN_CODE_LENGTH, Utils.ADMIN_CODE_LENGTH, Utils.APP_ID_LENGTH,
				Utils.USER_ID_LENGTH, Utils.MODE_LENGTH, Utils.LOCK_NAME_LENGTH, Utils.PROVIDER_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_PREV_ADMIN_CODE, Utils.STR_ADMIN_CODE, Utils.STR_APP_ID,
				Utils.STR_USER_ID, Utils.STR_MODE, Utils.STR_LOCK_NAME, Utils.STR_PROVIDER_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		if (b)
			startTimer(command);
		
		return b;
	}
	
//	public boolean downloadParamsRequest(Bundle params) 
//	{
//		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;
//		byte command = Utils.ENUM_CMD_DOWNLOAD_PARAMS_REQUEST;
//		
//		int[] itemsLengths = {CMD_LEN, Utils.DP_LENGTH_LENGTH, Utils.DP_FLAGS_LENGTH, Utils.PREFERRED_START_ADDRESS_LENGTH, Utils.PREFERRED_CHUNK_SIZE_LENGTH};
//		String[] items = {Utils.STR_COMMAND, Utils.STR_DP_LENGTH, Utils.STR_DP_FLAGS, Utils.STR_PREFERRED_START_ADDRESS, Utils.STR_PREFERRED_CHUNK_SIZE};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		if (b)
//			startTimer(command);
//		
//		return b;
//	}
//	
//	private byte[] otaData = null;
//	private int chunkNum = 0;
//	
//	public boolean otaUpdate(Bundle params) {
//		
//		Bundle bundle = new Bundle();
//		
//		boolean success = true;
//		
//		otaData = params.getByteArray(Utils.STR_OTA_UPDATE_DATA);
//		
//		int startAddress = params.getInt(Utils.STR_PREFERRED_START_ADDRESS, 0);
//		
//		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE, 512);
//		
//		ByteArrayBuffer data = new ByteArrayBuffer(chunkSize);
//		
//		int numChunksSize = Utils.CHUNK_NUM_LENGTH_16;
////		int numChunksSize = Utils.CHUNK_NUM_LENGTH_8;
//		
//		while (startAddress + (chunkNum * chunkSize) < otaData.length)
//		{
//			data.clear();
//			int len = otaData.length - (startAddress + (chunkNum * chunkSize));
//			data.append(otaData, startAddress + (chunkNum * chunkSize) , len < chunkSize ? len : chunkSize);	
//			bundle.putByteArray(Utils.STR_CHUNK_NUM, Utils.toBytes(chunkNum, numChunksSize));
//			Log.d(TAG, "sending OTA chunk number: " + chunkNum);
//			chunkNum++;
//			bundle.putByteArray(Utils.STR_OTA_UPDATE_DATA, data.buffer());
//			bundle.putInt(Utils.STR_PREFERRED_CHUNK_SIZE, chunkSize);
//			if (numChunksSize == Utils.CHUNK_NUM_LENGTH_16)
//				success = downloadChunk16(bundle);
//			else 
//				success = downloadChunk8(bundle);
//			if (!success)
//				return false;
//			try {
//				synchronized(object){
//					object.wait();//200);
//		        }
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
//		
//		success = downloadComplete();
//		
//		return success;
//	}
//	
//	public boolean downloadChunk16(Bundle params) {
//
//		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;
//		byte command = Utils.ENUM_CMD_DOWNLOAD_CHUNK_16;
//		
//		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE);
//		
//		int[] itemsLengths = {CMD_LEN, Utils.CHUNK_NUM_LENGTH_16, chunkSize};
//		String[] items = {Utils.STR_COMMAND, Utils.STR_CHUNK_NUM, Utils.STR_OTA_UPDATE_DATA};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		if (b)
//			startTimer(command);
//		
//		return b;
//	}
//	
//	public boolean downloadChunk8(Bundle params) {
//
//		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;
//		byte command = Utils.ENUM_CMD_DOWNLOAD_CHUNK_8;
//		
//		int chunkSize = params.getInt(Utils.STR_PREFERRED_CHUNK_SIZE);
//		
//		int[] itemsLengths = {CMD_LEN, Utils.CHUNK_NUM_LENGTH_8, chunkSize};
//		String[] items = {Utils.STR_COMMAND, Utils.STR_CHUNK_NUM, Utils.STR_OTA_UPDATE_DATA};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		if (b)
//			startTimer(command);
//		
//		return b;
//	}
//	
//	public boolean downloadComplete() {
//		
//		Bundle params = new Bundle();
//
//		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;
//		byte command = Utils.ENUM_CMD_DOWNLOAD_COMPLETE;
//		
//		params.putByte(Utils.STR_COMMAND, command);
//		
//		int[] itemsLengths = {CMD_LEN};
//		String[] items = {Utils.STR_COMMAND};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		return b;
//	}
//	
//	public boolean onInstallRequest() {
//		
//		Bundle params = new Bundle();
//
//		byte cmd = Utils.ENUM_CMD_GENERAL_PLAIN;
//		byte command = Utils.ENUM_CMD_INSTALL_REQUEST;
//		
//		params.putByte(Utils.STR_COMMAND, command);
//		
//		int[] itemsLengths = {CMD_LEN};
//		String[] items = {Utils.STR_COMMAND};
//		
//		ByteArrayBuffer data = getBuffer2FromBundle(params, command, itemsLengths, items, useFOTASecurity);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		return b;
//	}
//	
//	public boolean onResendChunk(Bundle params) {
//
//		return downloadChunk16(params);
//	}
	
	public boolean setDeviceConfig(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_OP_DEVICE_CONFIG;

//command                1
//app id                16       
//OwnerCode              6      
//New OwnerCode          6    
//Lock Config            1 byte      (0- Always 1) 1- Auto 0 = auto 2 - mute    
//RequiresCode           4           (0000 - NO, other YES) 0000 if not,
//Lock name             16   
		
		int[] itemsLengths = {CMD_LEN, Utils.APP_ID_LENGTH, Utils.PREV_ADMIN_CODE_LENGTH, Utils.ADMIN_CODE_LENGTH,
				Utils.DEVICE_STATUS_LENGTH, Utils.OWNER_UNLOCK_CODE_LENGTH, Utils.LOCK_NAME_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_APP_ID, Utils.STR_PREV_ADMIN_CODE, Utils.STR_ADMIN_CODE,
				Utils.STR_DEVICE_STATUS, Utils.STR_OWNER_UNLOCK_CODE, Utils.STR_LOCK_NAME};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		if (b)
			startTimer(command);
		
		return b;
	}

	public boolean agreeOnKey(Bundle params) {
		byte cmd = Utils.ENUM_CMD_KDF;
		
		int[] itemsLengths = {Utils.BLE_ASSOCIATION_ID_LENGTH};
		String[] items = {Utils.STR_BLE_ASSOCIATION_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, (byte)0, itemsLengths, items, false);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean unlock(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_UNLOCK;
		
		int[] itemsLengths = {CMD_LEN, Utils.USER_ID_LENGTH, Utils.APP_ID_LENGTH, Utils.BLE_EKEY_LENGTH, Utils.MODE_LENGTH, Utils.OWNER_UNLOCK_CODE_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_USER_ID, Utils.STR_APP_ID, Utils.STR_BLE_EKEY, Utils.STR_MODE, Utils.STR_OWNER_UNLOCK_CODE};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean lock(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_LOCK;
		
		int[] itemsLengths = {CMD_LEN, Utils.USER_ID_LENGTH, Utils.APP_ID_LENGTH, Utils.BLE_EKEY_LENGTH, Utils.MODE_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_USER_ID, Utils.STR_APP_ID, Utils.STR_BLE_EKEY, Utils.STR_MODE};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean config(Bundle params) {
		boolean b;
		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte[] command = new byte[CMD_LEN];
		command[0] = Utils.ENUM_CMD_OP_CONFIG;

		byte[] configId = new byte[Utils.CONFIG_ID_LENGTH];
		configId[0] = params.getByte(Utils.STR_CONFIG_ID);

		byte valueLen = params.getByte(Utils.STR_CONFIG_VALUE_LENGTH);

		byte[] value;
		if (valueLen == 1) {
			byte value1 = params.getByte(Utils.STR_CONFIG_VALUE);
			value = new byte[valueLen];
			value[0] = value1;
		} else {
			value = params.getByteArray(Utils.STR_CONFIG_VALUE);
		}

		byte[] valueLenArray = new byte[Utils.CONFIG_VALUE_LENGTH];
		valueLenArray[0] = valueLen;

		ByteArrayBuffer data = new ByteArrayBuffer(CMD_LEN + Utils.CONFIG_ID_LENGTH + Utils.CONFIG_VALUE_LENGTH + valueLen);

		data.append(command, 0, CMD_LEN);
		data.append(configId, 0, Utils.CONFIG_ID_LENGTH);
		data.append(valueLenArray, 0, Utils.CONFIG_VALUE_LENGTH);
		data.append(value, 0, valueLen);
		
		//encrypt the data since moved to getBuffer
		byte[] tmpBuffer = null;
		if (this.securityOn)
		{
			try {
				tmpBuffer = SecUtils.encrypt(null, data.buffer(), null);
			} catch (GeneralSecurityException e) {
				e.printStackTrace();
			}
			if (tmpBuffer == null)
				return false;
		}
		
		data = new ByteArrayBuffer(tmpBuffer.length);
		data.append(tmpBuffer, 0, tmpBuffer.length);
		
		b = sendCommand(cmd, data, mActiveIndex);
		return b;
	}
	
	public boolean createNewKey(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_CREATE_NEW_KEY;
		
		int[] itemsLengths = {CMD_LEN, Utils.ADMIN_CODE_LENGTH, Utils.USER_ID_LENGTH, Utils.NEW_USER_PIN_LENGTH, 
				Utils.EXPIRATION_LENGTH, Utils.ROLE_LENGTH, Utils.APP_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ADMIN_CODE, Utils.STR_USER_ID, Utils.STR_NEW_USER_PIN,
				Utils.STR_EXPIRATION, Utils.STR_ROLE, Utils.STR_APP_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean getNewKey(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_GET_NEW_KEY;
		
		int[] itemsLengths = {CMD_LEN, Utils.NEW_USER_PIN_LENGTH, Utils.APP_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_NEW_USER_PIN, Utils.STR_APP_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean getKeys(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_GET_KEYS;
		
		int[] itemsLengths = {CMD_LEN, Utils.ADMIN_CODE_LENGTH, Utils.APP_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ADMIN_CODE, Utils.STR_APP_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean actoinOnKey(Bundle params, int action) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = (byte)action;
		
		int[] itemsLengths = {CMD_LEN, Utils.ADMIN_CODE_LENGTH, Utils.APP_ID_LENGTH, Utils.USER_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ADMIN_CODE, Utils.STR_APP_ID, Utils.STR_USER_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}
	
	public boolean recoverOwner(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_RECOVER_OWNER;
		
		int[] itemsLengths = {CMD_LEN, Utils.ADMIN_CODE_LENGTH, Utils.APP_ID_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ADMIN_CODE, Utils.STR_APP_ID};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean setAdminCode(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_SET_ADMIN_CODE;
		
		int[] itemsLengths = {CMD_LEN, Utils.USER_ID_LENGTH, Utils.APP_ID_LENGTH, Utils.ADMIN_CODE_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_USER_ID, Utils.STR_APP_ID, Utils.STR_ADMIN_CODE};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean getDeviceConfig(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
		byte command = Utils.ENUM_CMD_GET_DEVICE_CONFIG;
		
		int[] itemsLengths = {CMD_LEN, Utils.ADMIN_CODE_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ADMIN_CODE};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}

	public boolean getCommunicationVersion(Bundle params) {

		byte cmd = Utils.ENUM_CMD_GET_COMMUNICATION_VERSION;
		byte command = (byte)0;
		
		int[] itemsLengths = {CMD_LEN};
		String[] items = {Utils.STR_COMMAND};
		
		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, false);
		
		if (data == null)
			return false;
		
		boolean b = sendCommand(cmd, data, mActiveIndex);
		
		return b;
	}
	
//	public boolean getDeviceInfo(Bundle params) {
//		byte cmd = Utils.ENUM_CMD_GENERAL_ENCRYPTED;
//		byte command = Utils.ENUM_CMD_GET_DEVICE_INFO;
//		
//		int[] itemsLengths = {CMD_LEN};
//		String[] items = {Utils.STR_COMMAND};
//		
//		ByteArrayBuffer data = getBufferFromBundle(params, command, itemsLengths, items, true);
//		
//		if (data == null)
//			return false;
//		
//		boolean b = sendCommand(cmd, data, mActiveIndex);
//		
//		return b;
//	}

	public boolean IsConnected() {
		return stateConnected;
	}
	
	public boolean IsConnected(int index) {
		return (this.getGattFromId(index) != null);
	}
	
	public boolean IsScanFreeze() {
		return scanFreeze;
	}
	
	public void setScanFreeze(boolean freeze) {
		scanFreeze = freeze;
	}
	
	
	public int getCurrentActiveIndex()
	{
		return mActiveIndex;
	}
	
	//*** BLUETOOTH INFRASTRUCTURE

	/*
	 * In this callback, we've created a bit of a state machine to enforce that
	 * only one characteristic be read or written at a time until all of our
	 * sensors are enabled and we are registered to get notifications.
	 */
	
	private boolean enableCharacteristic(BluetoothGatt gatt, BluetoothGattCharacteristic resChar) {
		boolean b = gatt.setCharacteristicNotification(resChar, true);
		if (!b)
			return false;

		// Enabled remote notifications
		List<BluetoothGattDescriptor> l = resChar.getDescriptors();
		BluetoothGattDescriptor desc = null;
		int size = l.size();
		if (size > 0) {
			desc = l.get(size - 1);
		} else {
			desc = resChar.getDescriptor(CONFIG_DESCRIPTOR);
		}
		resChar.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
								// 2=DEFAULT;4=WRITE_TYPE_SIGNED
		b = desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
		if (!b)
			return false;

		b = gatt.writeDescriptor(desc);
		if (!b)
			return false;
		return true;
	}
	
	public void enableNextCharacteristic(BluetoothGatt gatt) {
		// BluetoothGattCharacteristic characteristic;
		BluetoothGattCharacteristic resChar;
		boolean b;
		switch (mState) {
		case 0:
			Log.d(TAG, "Enabling PrimaryResponse");
			resChar = resService.getCharacteristic(RESPONSE_PRIMARY);
			// Enable local notifications
			this.enableCharacteristic(gatt, resChar);
			break;
		case 1:
			if (!fotaSupported) {
				enableDone = true;
				ble_interface.onDiscoverServiceDone();
				break;
			}
			Log.d(TAG, "Enabling SecondaryResponse");
			resChar = resService.getCharacteristic(RESPONSE_SECONDARY);
			// Enable local notifications
			this.enableCharacteristic(gatt, resChar);
			break;
		case 2:
//			if (!fotaSupported) {
//				enableDone = true;
//				break;
//			}
			Log.d(TAG, "Enabling FotaControlResponse");
			resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_CONTROL);
			// Enable local notifications
			this.enableCharacteristic(gatt, resChar);
			break;
		case 3:
			Log.d(TAG, "Enabling FotaPayloadResponse");
			resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_PAYLOAD);
			// Enable local notifications
			this.enableCharacteristic(gatt, resChar);
			break;
		default:
			// mHandler.sendEmptyMessage(MSG_DISMISS);
			Log.i(TAG, "All Characteristics Enabled");
			enableDone = true;
			ble_interface.onDiscoverServiceDone();
		}

		// gatt.writeCharacteristic(characteristic);
	}

	
	private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {

		@Override
		public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
			Log.d(TAG, "Connection State Change: " + status + " -> " + connectionState(newState));
			if (status == BluetoothGatt.GATT_SUCCESS && newState == BluetoothProfile.STATE_CONNECTED) {
				/*
				 * Once successfully connected, we must next discover all the
				 * services on the device before we can read and write their
				 * characteristics.
				 */

				//we received success on Connect - stop the timer
				stopTimer(Utils.ENUM_CMD_CONNECT);
				
				mActiveGatt = gatt;
				
				startTime = System.currentTimeMillis();
				gatt.discoverServices();

				stateConnected = true;
				ble_interface.onGattConnected(mActiveIndex);

				// mHandler.sendEmptyMessage(2);
			} else if (status == BluetoothGatt.GATT_SUCCESS && newState == BluetoothProfile.STATE_DISCONNECTED) {
				/*
				 * If at any point we disconnect, send a message to clear the
				 * weather values out of the UI
				 */
				Log.d(TAG, "State Disconnected");

				stateConnected = false;
				
				if (mActiveIndex != -1 && mActiveIndex < bleDevices[currentFinal].size())
					bleDevices[currentFinal].get(mActiveIndex).mConnectedGatt = null;
			
				mActiveGatt = null;
				ble_interface.onGattDisconnected(mActiveIndex);
				mActiveIndex = -1;
				
				// mHandler.sendEmptyMessage(3);
			} else if (status != BluetoothGatt.GATT_SUCCESS) {
				/*
				 * If there is a failure at any stage, simply disconnect
				 */
				
				//we received an eror on Connect - stop the timer
				stopTimer(Utils.ENUM_CMD_CONNECT);
				
				stateConnected = false;
				gatt.disconnect();
				//gatt.close();
				ble_interface.onGattError();
			}
		}


		private void loopTest(BluetoothGatt gatt) {
			List<BluetoothGattService> gattServices = gatt.getServices();
			if (gattServices == null)
				return;
			String uuid = null;
			String unknownServiceString = "unknown service";
			String unknownCharaString = "unknown characteristic";

			// Loops through available GATT Services.
			for (BluetoothGattService gattService : gattServices) {
				uuid = gattService.getUuid().toString();
				List<BluetoothGattCharacteristic> gattCharacteristics = gattService.getCharacteristics();

				// Loops through available Characteristics.
				for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {

					uuid = gattCharacteristic.getUuid().toString();
				}

			}
		}

		@Override
		public void onServicesDiscovered(BluetoothGatt gatt, int status) {
			boolean b;

			boolean loop_test = false;
			if (loop_test)
				this.loopTest(gatt);

			BluetoothGattCharacteristic resChar;
			//BluetoothGattService gattService;
			mActiveGatt = gatt;
//			gattService = cmdService = mActiveGatt.getService(REQUEST_SERVICE);
//			gattService = resService = mActiveGatt.getService(RESPONSE_SERVICE);
			cmdService = mActiveGatt.getService(REQUEST_SERVICE);
			resService = mActiveGatt.getService(RESPONSE_SERVICE);
			if (fotaSupported)
				FotaBleUtils.fotaService = mActiveGatt.getService(FotaBleUtils.FOTA_SERVICE);
			if (cmdService == null || resService == null || (fotaSupported && FotaBleUtils.fotaService == null)) {
				ble_interface.onDiscoverServiceFailed();
				// mHandler.sendEmptyMessage(8);
				return;
			}
			resChar = resService.getCharacteristic(RESPONSE_CONTROL);
			if (resChar == null) {
				ble_interface.onDiscoverServiceFailed();
				// mHandler.sendEmptyMessage(8);
				return;
			}
			// Enable local notifications
			b = enableCharacteristic(gatt, resChar);
			if (!b) {
				ble_interface.onDiscoverServiceFailed();
				// mHandler.sendEmptyMessage(8);
				return;
			}
//			
//			resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_CONTROL);
//			if (resChar == null) {
//				ble_interface.onDiscoverServiceFailed();
//				// mHandler.sendEmptyMessage(8);
//				return;
//			}
//			// Enable local notifications
//			b = this.enableCharacteristic(gatt, resChar);
//			if (!b) {
//				ble_interface.onDiscoverServiceFailed();
//				// mHandler.sendEmptyMessage(8);
//				return;
//			}
//			
//			resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_PAYLOAD);
//			if (resChar == null) {
//				ble_interface.onDiscoverServiceFailed();
//				// mHandler.sendEmptyMessage(8);
//				return;
//			}
//			// Enable local notifications
//			b = this.enableCharacteristic(gatt, resChar);
//			if (!b) {
//				ble_interface.onDiscoverServiceFailed();
//				// mHandler.sendEmptyMessage(8);
//				return;
//			}
//
//			ble_interface.onDiscoverServiceDone();
		}

//		private boolean enableCharacteristic(BluetoothGatt gatt, BluetoothGattCharacteristic resChar) {
//			boolean b = gatt.setCharacteristicNotification(resChar, true);
//			if (!b)
//				return false;
//
//			// Enabled remote notifications
//			List<BluetoothGattDescriptor> l = resChar.getDescriptors();
//			BluetoothGattDescriptor desc = null;
//			int size = l.size();
//			if (size > 1110) {
//				desc = l.get(size - 1);
//			} else {
//				desc = resChar.getDescriptor(CONFIG_DESCRIPTOR);
//			}
//			resChar.setWriteType(2);// 1=WRITE_TYPE_NO_RESPONSE;
//									// 2=DEFAULT;4=WRITE_TYPE_SIGNED
//			b = desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
//			if (!b)
//				return false;
//			b = gatt.writeDescriptor(desc);
//			if (!b)
//				return false;
//			return true;
//		}
//
//		public void enableNextCharacteristic(BluetoothGatt gatt) {
//			// BluetoothGattCharacteristic characteristic;
//			BluetoothGattCharacteristic resChar;
//			boolean b;
//			switch (mState) {
//			case 0:
//				Log.d(TAG, "Enabling PrimaryResponse");
//				resChar = resService.getCharacteristic(RESPONSE_PRIMARY);
//				// Enable local notifications
//				this.enableCharacteristic(gatt, resChar);
//				break;
//			case 1:
//				Log.d(TAG, "Enabling SecondaryResponse");
//				resChar = resService.getCharacteristic(RESPONSE_SECONDARY);
//				// Enable local notifications
//				this.enableCharacteristic(gatt, resChar);
//				break;
//			case 2:
//				Log.d(TAG, "Enabling FotaControlResponse");
//				resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_CONTROL);
//				// Enable local notifications
//				this.enableCharacteristic(gatt, resChar);
//				break;
//			case 3:
//				Log.d(TAG, "Enabling FotaPayloadResponse");
//				resChar = FotaBleUtils.fotaService.getCharacteristic(FotaBleUtils.FOTA_RESPONSE_PAYLOAD);
//				// Enable local notifications
//				this.enableCharacteristic(gatt, resChar);
//				break;
//			default:
//				// mHandler.sendEmptyMessage(MSG_DISMISS);
//				Log.i(TAG, "All Characteristics Enabled");
//				enableDone = true;
//			}
//
//			// gatt.writeCharacteristic(characteristic);
//		}

		@Override
		public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
			// For each read, pass the data up to the UI thread to update the
			// display
			if (REQUEST_CHAR_CONTROL.equals(characteristic.getUuid())) {
				lastReq = characteristic.getValue();
				// Toast.makeText(context, "Read from Command Char = " +
				// Integer.toString(lastReq), Toast.LENGTH_SHORT).show();
			} else if (RESPONSE_CONTROL.equals(characteristic.getUuid())) {
				// int val = lastRes = characteristic.getIntValue(18 , 0);
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = handleControlResponse(val);
				if (!ret) {
					ble_interface.onRequestError(null);
					return;
				}
				ble_interface.onResponseControlRead();
				// mHandler.sendEmptyMessage(1);
			} else if (RESPONSE_PRIMARY.equals(characteristic.getUuid())) {
				// int val = lastRes = characteristic.getIntValue(18 , 0);
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = handlePayloadResponse(val, true);
				if (!ret) {
					ble_interface.onRequestError(null);
					return;
				}
				ble_interface.onResponsePrimaryRead();
				// mHandler.sendEmptyMessage(1);
			} else if (RESPONSE_SECONDARY.equals(characteristic.getUuid())) {
				// int val = lastRes = characteristic.getIntValue(18 , 0);
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = handlePayloadResponse(val, false);
				if (!ret) {
					ble_interface.onRequestError(null);
					return;
				}
				ble_interface.onResponsePrimaryRead();
				// mHandler.sendEmptyMessage(1);
			}
		}

		@Override
		public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
			// time_after = System.currentTimeMillis();
			// write_count++;
			if (mActiveGatt == null) {
				Log.d(TAG, "requests - write notify - mActiveGatt is null");
				return;
			}


			// loopTest(mConnectedGatt);
			if (status != BluetoothGatt.GATT_SUCCESS) {
				ble_interface.onGattError();
				// mHandler.sendEmptyMessage(5);
				Log.d(TAG, "requests - write notify - status != BluetoothGatt.GATT_SUCCESSl");

				return;
			}

			
			if (FotaBleUtils.fotaService != null) {
				if (FotaBleUtils.FOTA_REQUEST_CONTROL.equals(characteristic.getUuid()) || FotaBleUtils.FOTA_REQUEST_PAYLOAD.equals(characteristic.getUuid())) {
					synchronized (FotaBleUtils.fotaObject) {
						FotaBleUtils.fotaObject.notify();
						return;
					}
				}
			}
			if (resService != null) 
			{
				if (REQUEST_CHAR_CONTROL.equals(characteristic.getUuid()) || REQUEST_CHAR_PAYLOAD.equals(characteristic.getUuid())) {
					synchronized (object) {
						object.notify();
					}

					long time = System.currentTimeMillis();
					if (pendingSetOwner) {
						pendingSetOwner = false;
						ble_interface.onSetOwnerResponse(pendingBundle);
						Log.d(TAG, "requests - set owner ack write notify time succeeded at: " + time);
					} else if (pendingNewKey) {
						pendingNewKey = false;
						ble_interface.onGetNewKeyResponse(pendingBundle);
						Log.d(TAG, "requests - new key ack write notify time succeeded at: " + time);
					} else {
						ble_interface.onRequestControlWrite();
						Log.d(TAG, "requests - general write notify time succeeded at: " + time);
					}
				}
			}
		}

		@Override
		public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
			/*
			 * After notifications are enabled, all updates from the device on
			 * characteristic value changes will be posted here. Similar to
			 * read, we hand these up to the UI thread to update the display.
			 */
			boolean b = true;
			if (RESPONSE_CONTROL.equals(characteristic.getUuid())) {
				// characteristic = gattService.getCharacteristic(COMMAND_CHAR);
				// //////b = mConnectedGatt.readCharacteristic(characteristic);
				// Toast.makeText(context, "Command Char changed",
				// Toast.LENGTH_SHORT).show();

				byte val[] = lastRes = characteristic.getValue();
				boolean ret = handleControlResponse(val);
				if (!ret)
					ble_interface.onRequestError(null);

				ble_interface.onResponseControlChanged();
				// mHandler.sendEmptyMessage(1);

			} else if (RESPONSE_PRIMARY.equals(characteristic.getUuid())) {
				// b = mConnectedGatt.readCharacteristic(characteristic);
				// mHandler.sendEmptyMessage(0);
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = handlePayloadResponse(val, true);

				ble_interface.onResponsePrimaryChanged();
				// mHandler.sendEmptyMessage(1);

			} else if (RESPONSE_SECONDARY.equals(characteristic.getUuid())) {
				b = mActiveGatt.readCharacteristic(characteristic);
				ble_interface.onResponseSecondaryChanged();
				// mHandler.sendEmptyMessage(0);
			} else if (FotaBleUtils.FOTA_RESPONSE_CONTROL.equals(characteristic.getUuid())) {
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = fota.handleControlResponse(val);
//				if (!ret)
//					ble_interface.onFotaRequestError(null);

//				ble_interface.onFotaResponseControlChanged();
			} else if (FotaBleUtils.FOTA_RESPONSE_PAYLOAD.equals(characteristic.getUuid())) {
				byte val[] = lastRes = characteristic.getValue();
				boolean ret = fota.handlePayloadResponse(val, true);

//				ble_interface.onFotaResponsePrimaryChanged();
			}
		}

		@Override
		public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
			if (!enableDone) {
				Message msg = new Message();
				msg.what = 999;
				msg.obj = gatt;
				mHandler.sendMessage(msg);
//				this.enableNextCharacteristic(gatt);
//				advance();
				return;
			}
		}

		@Override
		public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {
			Log.d(TAG, "Remote RSSI: " + rssi);
		}

		private String connectionState(int status) {
			switch (status) {
			case BluetoothProfile.STATE_CONNECTED:
				return "Connected";
			case BluetoothProfile.STATE_DISCONNECTED:
				return "Disconnected";
			case BluetoothProfile.STATE_CONNECTING:
				return "Connecting";
			case BluetoothProfile.STATE_DISCONNECTING:
				return "Disconnecting";
			default:
				return String.valueOf(status);
			}
		}
	};

	public void init(Context context, Handler mHandler, BleInterface ble_int) {
		this.context = context;
		ble_interface = ble_int;
		this.mHandler = mHandler;
		if (fotaSupported)
			fota = new FotaBleUtils(ble_interface, mHandler);
		
		if (bleDevices[currentTemp] == null)
			bleDevices[currentTemp] = new DeviceLists();
		if (bleDevices[currentFinal] == null)
			bleDevices[currentFinal] = new DeviceLists();

		controlBuffer = new ByteArrayBuffer(20);
		payloadBuffer = new ByteArrayBuffer(20);
		/*
		 * Bluetooth in Android 4.3 is accessed via the BluetoothManager, rather
		 * than the old static BluetoothAdapter.getInstance()
		 */
		BluetoothManager manager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
		mBluetoothAdapter = manager.getAdapter();
		// bleDevices = new SparseArray<bleDevice>();
		//bleDevices = new ArrayList<bleDevice>();

		/*
		 * We need to enforce that Bluetooth is first enabled, and take the user
		 * to settings to enable it if they have not done so.
		 */
		if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
			// Bluetooth is disabled
			Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			context.startActivity(enableBtIntent);
			
			// finish();
			return;
		} 
	}
	
	public void setBleInterface(BleInterface ble)
	{
		this.ble_interface = ble;
	}

	public SparseArray<BluetoothDevice> getPairedDevices() {
		return null;
	}

	@Override
	public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
		// TODO Auto-generated method stub
		
		if (rssi < rssiLimit)
			return;
		String s = device.getName();
		Log.i(TAG, "New LE Device: " + s + " @ " + rssi);
		/*
		 * We are looking for SensorTag devices only, so validate the name that
		 * each device reports before adding it to our collection
		 */

		List<UUID> list = parseUUIDs(scanRecord);
		boolean legalDevice = false;
		if (list != null) {
			for (UUID a : list) {
				if (a.equals(REQUEST_SERVICE))
					legalDevice = true;
			}
		}

		if (!legalDevice)
			return;

		String name = device.getName();

		// mDevices.put(device.hashCode(), device);
		bleDevice btDevice = new bleDevice();
		btDevice.device = device;
		btDevice.lockState = scanRecord[Utils.ADVERTISE_DATA_LOCATION];
		btDevice.batteryPercent = scanRecord[Utils.ADVERTISE_BATTERY_STATUS_LOCATION];
		btDevice.deviceStatus = scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION];
		Log.d(TAG, " ADVERTISE *** Lock State: " + btDevice.lockState + " Muted: " + isLockMuted(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION]) + " Auto: " + isLockAutoLocked(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION]) + " lock_locked: " + isLockLocked(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION])
				+ " Door_closed: " + isDoorClosed(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION]) + " Lock_charging: " + isLockCharging(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION])
				+ " battery_state: " + batteryString(getBatteryState(scanRecord[Utils.ADVERTISE_DEVICE_STATUS_LOCATION])) + " battery_% : " + scanRecord[Utils.ADVERTISE_BATTERY_STATUS_LOCATION]);
		btDevice.rssi = rssi;
		// bleDevices.put(btDevice.hashCode(), btDevice);
		if (ble_interface.isDeviceApproved(btDevice))
		{
			insertSorted(btDevice);
			Log.d(TAG, "calling onLeScanDeviceFound");
			ble_interface.onLeScanDeviceFound(btDevice);
		}
	}

	private List<UUID> parseUUIDs(final byte[] advertisedData) {
		List<UUID> uuids = new ArrayList<UUID>();

		int offset = 0;
		while (offset < (advertisedData.length - 2)) {
			int len = advertisedData[offset++];
			if (len == 0)
				break;

			int type = advertisedData[offset++];
			switch (type) {
			case 0x02: // Partial list of 16-bit UUIDs
			case 0x03: // Complete list of 16-bit UUIDs
				while (len > 1) {
					int uuid16 = advertisedData[offset++];
					uuid16 += (advertisedData[offset++] << 8);
					len -= 2;
					uuids.add(UUID.fromString(String.format("%08x-0000-1000-8000-00805f9b34fb", uuid16)));
				}
				break;
			case 0x06:// Partial list of 128-bit UUIDs
			case 0x07:// Complete list of 128-bit UUIDs
				// Loop through the advertised 128-bit UUID's.
				while (len >= 16) {
					try {
						// Wrap the advertised bits and order them.
						ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);
						long mostSignificantBit = buffer.getLong();
						long leastSignificantBit = buffer.getLong();
						uuids.add(new UUID(leastSignificantBit, mostSignificantBit));
					} catch (IndexOutOfBoundsException e) {
						// Defensive programming.
						Log.e(TAG, e.toString());
						continue;
					} finally {
						// Move the offset to read the next uuid.
						offset += 15;
						len -= 16;
					}
				}
				break;
			default:
				offset += (len - 1);
				break;
			}
		}

		return uuids;
	}

	public void scanPairedDevices(int interval) {
		// mBluetoothAdapter.startLeScan(serviceUuids, this);
		// setProgressBarIndeterminateVisibility(true);

		mHandler.postDelayed(mStopRunnable, interval);
	}

	public void scanMTLTDevices(int interval) {
		// run the following to limit scan to listed services
		// mBluetoothAdapter.startLeScan(serviceUuids, this);

		mBluetoothAdapter.startLeScan(this);

		mHandler.postDelayed(mStopRunnable, interval);
	}
	
	private BleUtils me;
	
    public void autoScan(int scanTime, int waitTime) {
    	me = this;
    	this.scanTime = scanTime;
    	this.waitTime = waitTime;
        mBluetoothAdapter.startLeScan(this);
        mHandler.postDelayed(mStopAutoStart, scanTime);
    }
    
    private Runnable mStopAutoStart = new Runnable() {
        @Override
        public void run() {
            Log.d(TAG, "mStopAutoStart currentFinal before swapping: " + currentFinal);
            if (!IsScanFreeze()) {
                Log.d(TAG, "mStopAutoStart currentFinal - swapping: " + currentFinal);
	            //swap final and temporary arrays
	            currentFinal = currentTemp;
	            currentTemp = 1 - currentFinal;
	 
	            //clear the temporary list
	            bleDevices[currentTemp].clear();
	        	stopScan();
            } else {
            	mHandler.postDelayed(mStopAutoStart, waitTime);
            	return;
            }

            mHandler.postDelayed(mStartAutoStop, waitTime);
        }
    };
    
    private Runnable mStartAutoStop = new Runnable() {
        @Override
        public void run() {
        	mBluetoothAdapter.startLeScan(me);
            mHandler.postDelayed(mStopAutoStart, scanTime);
        }
    };

	public void disconnect(int index) {
		//BluetoothGatt gatt = getGattFromId(index);
		mHandler.removeCallbacks(mStopRunnable);
		mHandler.removeCallbacks(mStartRunnable);
		mHandler.removeCallbacks(mStartRunnablePaired);
		mBluetoothAdapter.stopLeScan(this);
		if (mActiveGatt != null) {
			mActiveGatt.disconnect();
			Log.d(TAG, "in disconnect - disconnect called");
//			if (mActiveGatt == gatt)
//				mActiveGatt = null;
			//change to -1 at the callback
			//mActiveIndex = -1;
			//mConnectedGatt.close();
			//mConnectedGatt = null;
		}
	}
	
	private BluetoothGatt getGattFromId(int index)
	{
		Log.d(TAG, "getGattFromId - list: " + currentFinal + " index = " + index);
		if (index >= bleDevices[currentFinal].size()) {
			Log.d(TAG, "getGattFroomId - object is null");
			return null;
		}
		bleDevice device = bleDevices[currentFinal].get(index);
		if (device == null)
			return null;
		BluetoothGatt gatt = device.mConnectedGatt;
		return gatt;
	}
	
	public void close(int index)
	{
		
//			disconnect(index);
		Log.d(TAG, "in Close - disconnect called");
		BluetoothGatt gatt = getGattFromId(index);
		if (gatt != null) {
		gatt.close();
//			if (mActiveGatt == gatt)
//			mActiveGatt = null;
//			mActiveIndex = -1;
		}
		disconnect(index);
	}

	private Runnable mStopRunnable = new Runnable() {
		@Override
		public void run() {
			Log.d(TAG, "mStopRunnable currentFinal before swapping: " + currentFinal);
            //swap final and temporary arrays
            BleUtils.currentFinal = BleUtils.currentTemp;
            BleUtils.currentTemp = 1 - BleUtils.currentFinal;
 
            //clear the new temporary list
            bleDevices[BleUtils.currentTemp].clear();
            
			stopScan();
		}
	};
	private Runnable mStartRunnablePaired = new Runnable() {
		@Override
		public void run() {
			scanPairedDevices(KNOWN_DEVICES_SCAN_INTERVAL);
		}
	};
	private Runnable mStartRunnable = new Runnable() {
		@Override
		public void run() {
			scanMTLTDevices(KNOWN_DEVICES_SCAN_INTERVAL);
		}
	};

	private void stopScan() {
		mBluetoothAdapter.stopLeScan(this);
		ble_interface.onStopScan();
	}
	
	
	//*** DEVICES FOUND UTILS

	public void insertSorted(bleDevice device) {
		int indexToAdd = -1;
		int rssi = device.rssi;
		Log.d(TAG, "entering InsertSorted");
		for (int i = 0; i < bleDevices[currentTemp].size(); i++) {
			int rssi_i = bleDevices[currentTemp].get(i).rssi;
			Log.d(TAG, "new rssi " + rssi + " rssi of device " + i + ": " + rssi_i);
			//String name = bleDevices.get(i).device.getName();
			String address = bleDevices[currentTemp].get(i).device.getAddress();
			//if (name.equals(device.device.getName()))
			//make uniqueness by mac address
			if (address.equals(device.device.getAddress()))
				return;
			if (rssi > rssi_i) {
				Log.d(TAG, "Inside IF - i = " + i);
				indexToAdd = i;				
				break;
			}
		}
		Log.d(TAG, "Index to add is : " + indexToAdd);
		Log.d(TAG, "adding device to position " + (indexToAdd > -1 ? indexToAdd : 0));
		if (indexToAdd == -1)
			bleDevices[currentTemp].add(device); 
		else
			bleDevices[currentTemp].add(indexToAdd, device);
		Log.d(TAG, "insert sorted to list: " + currentTemp);
	}

	public void clearDevices() {
		// mDevices.clear();
		bleDevices[currentFinal].clear();
		Log.d(TAG, "clearing devices from list: " + currentFinal);
	}

	public String getDeviceName(boolean finalList, int id) {
		// return getDeviceName(mDevices, id);
		int listID = (finalList ? currentFinal : currentTemp);

		return getDeviceName(bleDevices[listID], id);
	}
	
	public bleDevice getDevice(boolean finalList, int id) {
		// return getDeviceName(mDevices, id);
		int listID = (finalList ? currentFinal : currentTemp);

		return bleDevices[listID].get(id);
	}

	public byte getDeviceState(boolean finalList, int id) {
		// return getDeviceName(mDevices, id);
		int listID = (finalList ? currentFinal : currentTemp);
		
		if (id >= bleDevices[listID].size())
			return -1;
		return bleDevices[listID].get(id).lockState;
	}

	private String getDeviceName(List<bleDevice> list, int id) {
		// BluetoothDevice device = list.get(list.keyAt(id));
		// bleDevice device = list.get(list.keyAt(id));
		if (id >= list.size())
			return null;
		bleDevice device = list.get(id);
		if (device == null)
			return null;
		return device.device.getName();
	}

	public String getDeviceNameByKey(int key) {
		// BluetoothDevice device = mDevices.get(key);

		for (int i = 0; i < bleDevices[currentFinal].size(); i++) {
			int hash = bleDevices[currentFinal].get(i).hashCode();
			if (hash == key)
				return bleDevices[currentFinal].get(i).device.getName();
		}
		return null;
	}

	public int getKey(int id) {
		// return mDevices.keyAt(id);
		// return bleDevices.keyAt(id);
		if (id >= bleDevices[currentFinal].size())
			return 0;
		return bleDevices[currentFinal].get(id).hashCode();
	}

	public int getDeviceId(int id) {
		// return mDevices.keyAt(id);
		// BluetoothDevice device = mDevices.get(mDevices.keyAt(id));
		/*
		 * bleDevice device = bleDevices.get(bleDevices.keyAt(id)); if (device
		 * == null) return -1; return device.hashCode();
		 */
		if (id >= bleDevices[currentFinal].size())
			return 0;
		return bleDevices[currentFinal].get(id).hashCode();
	}

	public int connectDevice(int id) {
		try {
			// device = mDevices.get(mDevices.keyAt(id));
			// device = mDevices.get(id);
			if (id >= bleDevices[currentFinal].size())
				return -1;
			bleDevice ble = bleDevices[currentFinal].get(id);
			if (ble == null)
				return -1;
			
			Log.d(TAG, "connect device - list : " + currentFinal + " device ID: " + id);
			device = bleDevices[currentFinal].get(id).device;
			if (device == null)
			{
				Log.d(TAG, "connect device - device is null: " + currentFinal);
				return -1;
			}

			mActiveGatt = device.connectGatt(context, false, mGattCallback);
			ble.mConnectedGatt = mActiveGatt;
			mActiveIndex = id;
			reset();
			if (mActiveGatt != null)
			{
				//cmdService = mActiveGatt.getService(REQUEST_SERVICE);
				startTimer(Utils.ENUM_CMD_CONNECT);
				return 0;
			}

			// Toast.makeText(this, "Connected...", Toast.LENGTH_SHORT).show();
			else {
				// Toast.makeText(this, "Failed to Connect...",
				// Toast.LENGTH_SHORT).show();
				return -1;
			}
		} catch (Exception e) {
			e.printStackTrace();
			Log.d(TAG, "ERROR Connecting to " + device.getName());
			return -1;
		}
	}
	
	public int connectDevice(bleDevice btDevice) {
		try {
			
			Log.d(TAG, "connect device - ad hoc");
			device = btDevice.device;
			if (device == null)
			{
				Log.d(TAG, "connect device - device is null: " + currentFinal);
				return -1;
			}

			mActiveGatt = device.connectGatt(context, false, mGattCallback);
			btDevice.mConnectedGatt = mActiveGatt;
			//mActiveIndex = id;
			if (mActiveGatt != null)
			{
				//cmdService = mActiveGatt.getService(REQUEST_SERVICE);
				return 0;
			}

			// Toast.makeText(this, "Connected...", Toast.LENGTH_SHORT).show();
			else {
				// Toast.makeText(this, "Failed to Connect...",
				// Toast.LENGTH_SHORT).show();
				return -1;
			}
		} catch (Exception e) {
			e.printStackTrace();
			Log.d(TAG, "ERROR Connecting to " + device.getName());
			return -1;
		}
	}


	public String getConnectedDeviceName() {
		return mActiveGatt.getDevice().getName();
	}

	public int getDeviceSize(boolean finalList) {
		// return getDeviceListSize(mDevices);
		int listID = (finalList ? currentFinal : currentTemp);

		int l = bleDevices[listID].size();
		Log.d(TAG, "get device size: " + l + " list is: " + listID);
		return getDeviceListSize(bleDevices[listID]);
	}


	private int getDeviceListSize(List<bleDevice> list) {
		return list.size();
	}
	
	//***RESPONSE BUNDLES TO RETURN TO THE APP

	// implementation of calls from handleResponse to generate a bundle to the
	// interface
	
	private Bundle getBundleFromBuffer(int first, byte[] data, int[] itemsLengths, String[] items)
	{
		Bundle bundle = new Bundle();
		int length = 0;
		
		int start = first;
		int end = start + itemsLengths[0];
		
		for (int i=0; i < items.length; i++)
		{
			byte[] current = Arrays.copyOfRange(data, start, end);
			
			if (!items[i].equals(Utils.STR_IGNORE_VALUE)) {
				if (end - start > 1)
					bundle.putByteArray(items[i], current);
				else
					bundle.putByte(items[i], current[0]);
			}
			
			if (i < items.length -1) {
				if (itemsLengths[i] != Utils.PREV_VALUE_IS_LENGTH)
					start += itemsLengths[i];
				else 
					start += length;
				
				
				if (itemsLengths[i + 1] != Utils.PREV_VALUE_IS_LENGTH)
					end = start + itemsLengths[i + 1];
				else {
					length = this.fromByteArray(current);
					end = start + length;
				}
								
			}
		}

		return bundle;
	}
	
	private Bundle getPublicKeyBundle(byte[] data) {
		int[] itemsLengths = {Utils.PUBLIC_KEY_LENGTH, Utils.ECDSA_PUBLIC_KEY_LENGTH, Utils.IV_LENGTH};
		String[] items = {Utils.STR_PUBLIC_KEY, Utils.STR_ECDSA_PUBLIC_KEY, Utils.STR_IV};
		
		Bundle bundle = getBundleFromBuffer(0, data, itemsLengths, items);
		
		byte[] iv = bundle.getByteArray(Utils.STR_IV);
		byte[] remoteAES = bundle.getByteArray(Utils.STR_PUBLIC_KEY);
		byte[] remoteECDSA = bundle.getByteArray(Utils.STR_ECDSA_PUBLIC_KEY);
		
		SecUtils.initSecurityParamsForSession(iv, remoteAES, remoteECDSA);
		
//		mHandler.sendEmptyMessage(Utils.ENUM_CMD_HANDSHAKE1);

		return bundle;
	}

	private Bundle getHandshakeBundle(byte[] data) {
		int[] itemsLengths = {Utils.BLE_SIGNATURE_LENGTH};
		String[] items = {Utils.STR_BLE_SIGNATURE};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getKdfResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.IV_LENGTH, Utils.BLE_SIGNATURE_LENGTH, Utils.DEVICE_STATUS_LENGTH};
		String[] items = {Utils.STR_IV, Utils.STR_BLE_SIGNATURE, Utils.STR_DEVICE_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);
		
		byte[] iv = bundle.getByteArray(Utils.STR_IV);
		SecUtils.setNextIv(iv);
		
		byte status = bundle.getByte(Utils.STR_DEVICE_STATUS);
		
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_MUTE, isLockMuted(status));
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_AUTO_LOCK, isLockAutoLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_LOCKED, isLockLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_DOOR_CLOSED, isDoorClosed(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_CHARGING, isLockCharging(status));
		bundle.putInt(Utils.STR_DEVICE_STATE_BATTERY_STATE, getBatteryState(status));

		return bundle;
		
	}
	
	private Bundle getSetOwnerResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.BLE_EKEY_LENGTH, Utils.BLE_ASSOCIATION_ID_LENGTH, Utils.DEVICE_STATUS_LENGTH};
		String[] items = {Utils.STR_BLE_EKEY, Utils.STR_BLE_ASSOCIATION_ID, Utils.STR_DEVICE_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		byte id = bundle.getByte(Utils.STR_BLE_ASSOCIATION_ID);
		SecUtils.setLastHandshakeId(id);
		
		byte status = bundle.getByte(Utils.STR_DEVICE_STATUS);
		
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_MUTE, isLockMuted(status));
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_AUTO_LOCK, isLockAutoLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_LOCKED, isLockLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_DOOR_CLOSED, isDoorClosed(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_CHARGING, isLockCharging(status));
		bundle.putInt(Utils.STR_DEVICE_STATE_BATTERY_STATE, getBatteryState(status));

		return bundle;
	}
	
	private Bundle getNewKeyResponseBundle(byte[] data) {
		
		int[] itemsLengths = {Utils.BLE_EKEY_LENGTH, Utils.ROLE_LENGTH, Utils.PROVIDER_ID_LENGTH, 
				Utils.USER_ID_LENGTH, Utils.BLE_ASSOCIATION_ID_LENGTH, Utils.DEVICE_STATUS_LENGTH};
		String[] items = {Utils.STR_BLE_EKEY, Utils.STR_ROLE, Utils.STR_PROVIDER_ID,
				Utils.STR_USER_ID, Utils.STR_BLE_ASSOCIATION_ID, Utils.STR_DEVICE_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		byte id = bundle.getByte(Utils.STR_BLE_ASSOCIATION_ID);
		SecUtils.setLastHandshakeId(id);
		
		byte status = bundle.getByte(Utils.STR_DEVICE_STATUS);
		
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_MUTE, isLockMuted(status));
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_AUTO_LOCK, isLockAutoLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_LOCKED, isLockLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_DOOR_CLOSED, isDoorClosed(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_CHARGING, isLockCharging(status));
		bundle.putInt(Utils.STR_DEVICE_STATE_BATTERY_STATE, getBatteryState(status));

		return bundle;
	}

	private int getKeysResponseBundle(byte[] data) {

		//data contents
//		Command(1),	Keys left(1), Curr transport(1), Key (user name+role+state) (16+1+1), F*(RND)(32)
		int dataLength = Utils.USER_ID_LENGTH + 2;
		lockKeyData lock = new lockKeyData();
		int keysLeft = data[Utils.COMMAND_LENGTH];
		int numKeys = data[Utils.COMMAND_LENGTH+1];
		for (int i=0; i < numKeys; i++) {
			ByteArrayBuffer user = new ByteArrayBuffer(Utils.USER_ID_LENGTH);
			user.append(data, 3+i*dataLength, Utils.USER_ID_LENGTH);
			int role = data[3+i*dataLength+Utils.USER_ID_LENGTH];
			int state = data[3+i*dataLength+Utils.USER_ID_LENGTH+1]; //1 for role 1 for state
			lock.role = role;
			lock.user = user.buffer();
			lock.state = state;
			lockKeysList.add(lock);
		}
		
		if (keysLeft <= numKeys)
			return 0;
		else
			return (keysLeft - numKeys);
	}
	
	private Bundle getRecoverOwnerResponseBundle(byte[] data) {
		
		int[] itemsLengths = {Utils.BLE_EKEY_LENGTH, Utils.BLE_ASSOCIATION_ID_LENGTH, Utils.USER_ID_LENGTH, Utils.DEVICE_STATUS_LENGTH, Utils.PROVIDER_ID_LENGTH};
		String[] items = {Utils.STR_BLE_EKEY, Utils.STR_BLE_ASSOCIATION_ID, Utils.STR_USER_ID, Utils.STR_DEVICE_STATUS, Utils.STR_PROVIDER_ID};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		byte id = bundle.getByte(Utils.STR_BLE_ASSOCIATION_ID);
		SecUtils.setLastHandshakeId(id);
		
		byte status = bundle.getByte(Utils.STR_DEVICE_STATUS);
		
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_MUTE, isLockMuted(status));
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_AUTO_LOCK, isLockAutoLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_LOCKED, isLockLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_DOOR_CLOSED, isDoorClosed(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_CHARGING, isLockCharging(status));
		bundle.putInt(Utils.STR_DEVICE_STATE_BATTERY_STATE, getBatteryState(status));

		return bundle;
	}
	
	private Bundle getDeviceConfigResponseBundle(byte[] data) {
		// first byte device status - 2nd byte - battery percentage
		byte status = data[1];
		byte battery = data[2];
		
		
		Bundle bundle = new Bundle();

		int pos = Utils.COMMAND_LENGTH;
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_MUTE, isLockMuted(status));
		bundle.putBoolean(Utils.STR_DEVICE_CONFIG_AUTO_LOCK, isLockAutoLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_LOCKED, isLockLocked(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_DOOR_CLOSED, isDoorClosed(status));
		bundle.putBoolean(Utils.STR_DEVICE_STATE_LOCK_CHARGING, isLockCharging(status));
		bundle.putInt(Utils.STR_DEVICE_STATE_BATTERY_STATE, getBatteryState(status));
		bundle.putByte(Utils.STR_DEVICE_STATE_BATTERY_PERCENTAGE, battery);
		
		Log.d(TAG, " ENUM_CMD_GET_DEVICE_CONFIG_RESPONSE  --  Muted: " + isLockMuted(status) + " Auto: " + isLockAutoLocked(status) + " lock_locked: " + isLockLocked(status)
				+ " Door_closed: " + isDoorClosed(status) + " Lock_charging: " + isLockCharging(status)
				+ " battery_state: " + batteryString(getBatteryState(status)) + " battery_% : " + battery);

		return bundle;
	}
	
	private Bundle getOnSuccessBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH};
		String[] items = {Utils.STR_COMMAND};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnExplicitSuccessBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH};
		String[] items = {Utils.STR_COMMAND};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnErrorBundle(byte[] data) {
		int[] itemsLengths = {Utils.COMMAND_LENGTH, Utils.ERROR_CODE_TYPE_LENGTH, Utils.ERROR_CODE_DETAIL_LENGTH};
		String[] items = {Utils.STR_COMMAND, Utils.STR_ERROR_CODE_TYPE, Utils.STR_ERROR_CODE_DETAIL};
		
		Bundle bundle = getBundleFromBuffer(0, data, itemsLengths, items);

		return bundle;
	}

	private Bundle getOnOpStatusBundle(byte[] data) {
		Bundle bundle = new Bundle();

		int start = 0;
		int end = Utils.COMMAND_LENGTH;
		byte[] command = Arrays.copyOfRange(data, start, end);
		start += Utils.COMMAND_LENGTH;
		end = start + Utils.TYPE_ID_LENGTH;
		byte[] typeId = Arrays.copyOfRange(data, start, end);
		start += Utils.TYPE_ID_LENGTH;
		end = start + Utils.STATUS_VALUE_LENGTH;
		byte[] valueLen = Arrays.copyOfRange(data, start, end);
		if (valueLen[0] == 0)
			return null;
		int bValueLen = valueLen[0];
		start += Utils.STATUS_VALUE_LENGTH;
		end = start + bValueLen;
		byte[] value = Arrays.copyOfRange(data, start, end);

		bundle.putByteArray(Utils.STR_COMMAND, command);
		bundle.putByteArray(Utils.STR_STATUS_TYPE_ID, typeId);
		bundle.putByteArray(Utils.STR_STATUS_VALUE_LENGTH, valueLen);
		bundle.putByteArray(Utils.STR_STATUS_VALUE, value);

		return bundle;
	}
	
	private Bundle getOnGetCommVersionResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DEVICE_CODE_VERSION_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH};
		String[] items = {Utils.STR_IGNORE_VALUE, Utils.STR_COMMUNICATION_VERSION};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnGetDeviceInfoResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DEVICE_ID_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH, Utils.DEVICE_MODEL_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH, 
				Utils.DEVICE_CODE_VERSION_LENGTH_LENGTH, Utils.PREV_VALUE_IS_LENGTH};
		String[] items = {Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_ID, Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_MODEL, 
				Utils.STR_IGNORE_VALUE, Utils.STR_DEVICE_CODE_VERSION};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadParamsResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.PREFERRED_START_ADDRESS_LENGTH, Utils.PREFERRED_CHUNK_SIZE_LENGTH, Utils.IV_LENGTH};
		String[] items = {Utils.STR_PREFERRED_START_ADDRESS, Utils.STR_PREFERRED_CHUNK_SIZE, Utils.STR_IV};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadCompleteResponseBundle(byte[] data) {
		int[] itemsLengths = {Utils.DOWNLOAD_COMPLETE_STATUS_LENGTH, Utils.DP_CONTENT_LENGTH};
		String[] items = {Utils.STR_DOWNLOAD_COMPLETE_STATUS, Utils.STR_DP_CONTENT};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnInstallStatusBundle(byte[] data) {
		int[] itemsLengths = {Utils.INSTALL_STATUS_LENGTH};
		String[] items = {Utils.STR_INSTALL_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	
	private Bundle getOnDownloadChunkStatusBundle(byte[] data) {
		int[] itemsLengths = {Utils.CHUNK_NUM_LENGTH_16, Utils.DOWNLOAD_CHUNK_STATUS_LENGTH};
		String[] items = {Utils.STR_CHUNK_NUM, Utils.STR_DOWNLOAD_CHUNK_STATUS};
		
		Bundle bundle = getBundleFromBuffer(CMD_LEN, data, itemsLengths, items);

		return bundle;
	}
	

	@Override
	protected Boolean doInBackground(Bundle... arg0) {
		// TODO Auto-generated method stub
		Boolean rc = false;
		Bundle bundle = arg0[0];

		Byte command = bundle.getByte(Utils.STR_COMMAND);

		try {

			switch (command) {
			case Utils.ENUM_CMD_SEND_PUBLIC_KEY:
				Log.d(TAG, "calling SendPublicKey");
				rc = this.SendPublicKey(bundle);
				break;
			case Utils.ENUM_CMD_HANDSHAKE1:
				Log.d(TAG, "calling handShake");
				rc = this.handShake(bundle);
				break;
			case Utils.ENUM_CMD_SET_OWNER:
				Log.d(TAG, "calling setOwner");
				rc = this.setOwner(bundle);
				break;
			case Utils.ENUM_CMD_KDF:
				Log.d(TAG, "calling agreeOnKey");
				rc = this.agreeOnKey(bundle);
				break;
			case Utils.ENUM_CMD_GET_NEW_KEY:
				Log.d(TAG, "calling getNewKey");
				rc = this.getNewKey(bundle);
				break;
			case Utils.ENUM_CMD_CREATE_NEW_KEY:
				Log.d(TAG, "calling createNewKey");
				rc = this.createNewKey(bundle);
				break;
			case Utils.ENUM_CMD_UNLOCK:
				Log.d(TAG, "calling unlock");
				rc = this.unlock(bundle);
				break;
			case Utils.ENUM_CMD_LOCK:
				Log.d(TAG, "calling lock");
				rc = this.lock(bundle);
				break;
			case Utils.ENUM_CMD_OP_CONFIG:
				Log.d(TAG, "calling config");
				rc = this.config(bundle);
				break;
			case Utils.ENUM_CMD_GET_KEYS:
				Log.d(TAG, "calling getKeys");
				lockKeysList.clear();
				rc = this.getKeys(bundle);
				break;
			case Utils.ENUM_CMD_REVOKE_KEY:
				Log.d(TAG, "calling actoinOnKey - revoke");
				rc = this.actoinOnKey(bundle, Utils.ENUM_CMD_REVOKE_KEY);
				break;
			case Utils.ENUM_CMD_DISABLE_KEY:
				Log.d(TAG, "calling actoinOnKey - disable");
				rc = this.actoinOnKey(bundle, Utils.ENUM_CMD_DISABLE_KEY);
				break;
			case Utils.ENUM_CMD_ENABLE_KEY:
				Log.d(TAG, "calling actoinOnKey - enable");
				rc = this.actoinOnKey(bundle, Utils.ENUM_CMD_ENABLE_KEY);
				break;
			case Utils.ENUM_CMD_GET_DEVICE_CONFIG:
				Log.d(TAG, "calling getDeviceConfig");
				rc = this.getDeviceConfig(bundle);
				break;
			case Utils.ENUM_CMD_OP_DEVICE_CONFIG:
				Log.d(TAG, "calling setDeviceConfig");
				rc = this.setDeviceConfig(bundle);
				break;
			case Utils.ENUM_CMD_RECOVER_OWNER:
				Log.d(TAG, "calling recoverOwner");
				rc = this.recoverOwner(bundle);
				break;
			case Utils.ENUM_CMD_GET_COMMUNICATION_VERSION:
				Log.d(TAG, "calling getCommunicationVersion");
				rc = this.getCommunicationVersion(bundle);
				break;
			case Utils.ENUM_CMD_GET_DEVICE_INFO:
				Log.d(TAG, "calling getDeviceInfo");
//				rc = this.getDeviceInfo(bundle);
				rc = fota.getDeviceInfo(bundle);
				break;
			case Utils.ENUM_CMD_SET_ADMIN_CODE:
				Log.d(TAG, "calling setAdminCode");
				rc = this.setAdminCode(bundle);
				break;
			case Utils.ENUM_CMD_DOWNLOAD_PARAMS_REQUEST:
				Log.d(TAG, "calling downloadParamsRequest");
				rc = fota.downloadParamsRequest(bundle);
				break;
            case Utils.ENUM_CMD_DOWNLOAD_PARAMS_CHANGE_REQUEST:
                Log.d(TAG, "calling downloadParamsChangeRequest");
                rc = fota.downloadParamsChangeRequest(bundle);
                break;
			case Utils.ENUM_CMD_OTA_UPDATE:
				Log.d(TAG, "calling otaUpdate");
				rc = fota.otaUpdate(bundle);
				break;
			case Utils.ENUM_CMD_INSTALL_REQUEST:
				Log.d(TAG, "calling onInstallRequest");
				rc = fota.onInstallRequest();
				break;
			case Utils.ENUM_CMD_RESEND_CHUNK:
				Log.d(TAG, "calling onResendChunk");
				rc = fota.onResendChunk(bundle);
				break;
			case Utils.ENUM_CMD_DOWNLOAD_COMPLETE:
				Log.d(TAG, "calling onResendChunk");
				rc = fota.downloadComplete();
				break;		
			case Utils.ENUM_CMD_GET_ERRORS:
				Log.d(TAG, "calling onGetErrors");
				rc = fota.getErrors(bundle);
				break;
            case Utils.ENUM_CMD_GET_IV:
                Log.d(TAG, "calling onGetIV");
                rc = fota.getIV();
                break;
				
			default:
				rc = false;
				break;
			}
			return rc;
		} catch (IllegalStateException e) {
			e.printStackTrace();
			return false;
		}
	}

	@Override
	protected void onPostExecute(Boolean result) {
		if (!result)
			ble_interface.onExecutionError();
		return;
	}

}
